<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>吸顶你不得不知道的那些事儿</title>
      <link href="/2020/09/24/2020/%E5%90%B8%E9%A1%B6%E4%BD%A0%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
      <url>/2020/09/24/2020/%E5%90%B8%E9%A1%B6%E4%BD%A0%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>这次做双十一活动页面实现了各种各样奇怪的吸顶，列举了几种我觉得比较好的吸顶实现方法和他们的一些优缺点（怕自己后面又忘了，(<em>/ω＼</em>)）：</p><p>这里不推荐通过修改元素的<code>offsetTop</code>等定位属性来实现元素的吸顶，因为这种获取元素定位信息的方法调用时会触发页面<code>reflow</code>，造成性能损耗。</p><h2 id="position-sticky"><a href="#position-sticky" class="headerlink" title="position: sticky"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position" target="_blank" rel="noopener">position: sticky</a></h2><p><code>position</code> 的取值除了我们常用的那些<code>static</code>、<code>absolute</code>、<code>relative</code>、<code>fixed</code>，后来又添加了一条规则：<code>sticky</code>，顾名思义，他可以将元素粘黏到屏幕上，效果有点像 <code>position: relative</code> 和 <code>position: fixed</code> 的结合，当元素在屏幕内，表现为 <code>relative</code>，当元素快要滚出屏幕时，表现为 <code>fixed</code>，效果如下：</p><iframe height="299" style="width: 100%;" scrolling="no" title="sticky" src="https://codepen.io/includeios/embed/yLOGKrN?height=299&theme-id=light&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/includeios/pen/yLOGKrN' target="_blank" rel="noopener">sticky</a> by 阿汤哥的鼎  (<a href='https://codepen.io/includeios' target="_blank" rel="noopener">@includeios</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a></iframe><p>当元素滚动到顶部时，会粘黏在上边不再移动，吸顶元素的class为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tab</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="attribute">position</span>: sticky;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>其中 <code>top: 0</code>的意思是滚动到 <code>top</code>距离屏幕 <code>0px</code> 时粘黏，这个值也可以是<code>right</code>，<code>bottom</code>，<code>left</code>。</p><p><code>sticky</code> 他的定位相对于最近的<strong>“拥有滚动机制”</strong>的祖先上（当该祖先的 <code>overflow</code> 是 <code>hidden</code>、 <code>scroll</code>、 <code>auto</code>、或 <code>overlay</code>时），如下：这个吸顶就是相对于<code>.scroll-body</code>这个元素：</p><iframe height="265" style="width: 100%;" scrolling="no" title="sticky例子-2" src="https://codepen.io/includeios/embed/OJNrEmb?height=265&theme-id=light&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/includeios/pen/OJNrEmb' target="_blank" rel="noopener">sticky例子-2</a> by 阿汤哥的鼎  (<a href='https://codepen.io/includeios' target="_blank" rel="noopener">@includeios</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><p><code>sticky</code> 是我认为最简单的实现吸顶的写法了，但是 <code>sticky</code> 有个致命问题是他的效果受 <code>”你希望的定位可滚动元素“</code> 和 <code>sticky</code>元素之间的所有层级元素的影响。这之间的层级元素是不允许设置除 <code>overflow: visible</code> 以外的<code>overflow</code>设置，因为会改变定位的滚动容器（即使没有出现滚动条）。</p><p>就还是上面那个例子，<code>sticky</code>元素是 <code>.tab</code>，我们期望的定位可滚动元素是<code>.scroll-body</code>，他们之前嵌套了一层<code>scroll-body-2</code>，一但给<code>.scroll-body-2</code>设置了其他的<code>overflow属性</code>，那么对于<code>sticky</code>元素来说，可滚动元素就会变成了<code>.scroll-body-2</code>，而失去了我们期望的粘黏效果：</p><iframe height="265" style="width: 100%;" scrolling="no" title="sticky 例子3" src="https://codepen.io/includeios/embed/bGpOjVM?height=265&theme-id=light&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/includeios/pen/bGpOjVM' target="_blank" rel="noopener">sticky 例子3</a> by 阿汤哥的鼎  (<a href='https://codepen.io/includeios' target="_blank" rel="noopener">@includeios</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><p>上面的例子里我们给 <code>.scroll-body-2</code> 加上了 <code>overflow:auto</code> 样式，可以看到吸顶元素已经不能粘黏到 <code>.scroll-body</code> 上了</p><p><strong>支持度</strong></p><p>支持率已经很高了，只是chrome在一些table元素上不支持。</p><p><img src="/images/2020/image-20200923144949320.png" alt="image-20200923144949320"></p><h2 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API" target="_blank" rel="noopener">IntersectionObserver</a></h2><p><code>sticky</code>  虽然简单但有几弊端：1、对父级元素的 <code>overflow</code> 属性需要严格控制。2、只能做到元素的吸顶，如果样式上想做一些更炫酷的效果，比如吸到顶部时添加一个些额外的动画元素呀，或者吸顶时整个元素的样式都换种风格呀，这时 <code>sticky</code> 就有心无力了。</p><p>这时就不得不介绍一个动画小利器：<code>IntersectionObserver</code>，通过他基本上可以实现所有UED的奇思妙想，具体使用方法可以参考我之前写的一篇文章：<a href="https://www.tripod.fun/2019/09/26/2019/IntersectionObserver实现滚动交互/" target="_blank" rel="noopener">IntersectionObserver实现滚动交互</a>。</p><p>如下面这个例子，我们给 <code>.tab-container</code> 添加了一个<code>observer</code>，当他划动到边界时会给 <code>.tab</code>添加一个吸顶的 <code>class</code>，通过改变class来轻松实现各种样式效果。</p><iframe height="265" style="width: 100%;" scrolling="no" title="rNePLva" src="https://codepen.io/includeios/embed/rNePLva?height=265&theme-id=light&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/includeios/pen/rNePLva' target="_blank" rel="noopener">rNePLva</a> by 阿汤哥的鼎  (<a href='https://codepen.io/includeios' target="_blank" rel="noopener">@includeios</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><p>需要注意的是，<code>被observe的元素</code> 和 <code>改变class的元素</code> 不能是同一个元素，因为一但元素滚动到屏幕外，满足了 <code>!entriesItem.isIntersecting</code> 的条件，他就会被添加一个 <code>fixed</code> 样式又重新返回屏幕视野内了，从而不停的触发 <code>observe</code>。</p><p><strong>支持度</strong></p><p>爱了爱了</p><p><img src="/images/2020/image-20200924114341916.png" alt="image-20200924114341916"></p><h2 id="终极大法"><a href="#终极大法" class="headerlink" title="终极大法"></a>终极大法</h2><p><code>observe</code> 确实强大，但是他是通过改变 <code>class</code> 来实现效果的，一但css实现不了，那他就gg了。什么意思呢，就是上面那个例子里我们给 <code>.tab</code> 添加了 <code>position: fixed</code> 的样式，但是<code>fixed</code> 的定位本身有条限制：当元素祖先的 <code>transform</code>, <code>perspective</code> 或 <code>filter</code> 属性非 <code>none</code> 时，容器由视口改为该祖先。</p><p>也就是说，如果我们给 <code>.tab-container</code> 添加一个 <code>transform: translate(0px, 0px)</code>，<code>fixed</code> 的定位就不再是基于屏幕了，从而失去了我们想要的效果：</p><iframe height="265" style="width: 100%;" scrolling="no" title="observe 例子2" src="https://codepen.io/includeios/embed/xxVMONg?height=265&theme-id=light&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/includeios/pen/xxVMONg' target="_blank" rel="noopener">observe 例子2</a> by 阿汤哥的鼎  (<a href='https://codepen.io/includeios' target="_blank" rel="noopener">@includeios</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><p>然而在实际开发时我们难免会遇到父级元素绕不开 <code>overflow</code>，<code>transform</code> 等这些属性，可能有小伙伴就想通过改变 <code>.tab</code> 的 <code>offsetTop</code> 来实现了，但我还是倾向于将需要吸顶的元素写在 <code>拥有overflow，transform等属性元素</code> 的外面，通过绝对定位等方式在视觉上看起来和写在里面没有什么区别。</p><p><code>Vue teleport</code> 和 <code>React portals</code> 都能轻松实现将定位元素的业务逻辑写在嵌套组件里，但是元素传入到组件外部。比起修改 <code>offsetTop</code>，还是倾向于能用css实现的效果都用css实现，希望有朝一日，大家都不用再为动画苦恼（滑稽）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git合并原理</title>
      <link href="/2020/06/09/2020/git%E5%90%88%E5%B9%B6%E5%8E%9F%E7%90%861/"/>
      <url>/2020/06/09/2020/git%E5%90%88%E5%B9%B6%E5%8E%9F%E7%90%861/</url>
      
        <content type="html"><![CDATA[<p>相信刚开始使用git的时候大家都会遇到这些困惑：为什么我本地有些文件合并完远程代码后就消失了？我到底应该什么时候使用rebase什么时候使用merge？为什么我rebase代码时会有这么多冲突？</p><p>在我们搞清楚git的底层合并原理时，这些问题就迎刃而解了。</p><h2 id="Tree-Way-Merge"><a href="#Tree-Way-Merge" class="headerlink" title="Tree-Way Merge"></a>Tree-Way Merge</h2><p>假设有两个同学在各自的分支上对同一个文件进行修改，如下图：</p><p><img src="/images/2020/git1/image-20200603204547200.png" alt="image-20200603204547200"></p><p>这个时候我们需要合并两个分支成一个分支，如果我们只对这两个文件进行对比，那么在代码合并时，只知道这两个文件在第30行有差异，却不知道应该采纳谁的版本。</p><p>如果我知道这个文件的“原件”，那么通过和“原件”代码的对比就能推算出应该采用谁的版本：</p><p><img src="/images/2020/git1/image-20200603205137404.png" alt="image-20200603205137404"></p><p>图示可以看出，Mine中的代码和Base一样，说明Mine中并没有对这行代码做修改，而Yours中的代码和Base不一样，说明Yours在Base的基础上对这行代码做了修改，那么Yours和Mine合并应该采用Yours中的内容。</p><p>当然还有一种情况是三个文件的代码都不相同，这就需要我们自己手动去解决冲突了：</p><p><img src="/images/2020/git1/image-20200603205528518.png" alt="image-20200603205528518"></p><p>从上面的例子可以看出采用Tree-Way-Merge（也称为三向合并）原理来合并代码有个重要前提是可以找到两份代码的“原件”，而git因为记录了文件的提交历史，再通过自身的合并策略就可以找到两个commit的公共commit是哪个，从而通过比对代码来进行合并。</p><p>那么后面我们就来详细说一下<strong>git是如何记录提交历史</strong>和<strong>git的合并策略是怎么推算出公共commit</strong>的。</p><h2 id="git是如何记录提交历史的"><a href="#git是如何记录提交历史的" class="headerlink" title="git是如何记录提交历史的"></a>git是如何记录提交历史的</h2><p>我们在控制台执行<code>git init</code>，git会创建一个<code>.git</code>目录，这个目录包含了几乎所有git存储和操作的东西，结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">- config  &#x2F;&#x2F;项目特有的配置选项</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">- description  &#x2F;&#x2F;仓库描述信息，主要给gitweb等git托管系统使用</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">- HEAD  &#x2F;&#x2F;文件，记录目前正在使用的分支</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">- hooks&#x2F;  &#x2F;&#x2F; 目录，包含git的钩子脚本</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">- info&#x2F;   &#x2F;&#x2F; 目录，包含一个全局性排除文件， 用以放置那些不希望被记录在 .gitignore 文件中的忽略模式</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">- objects&#x2F;   &#x2F;&#x2F;目录，存储所有的数据内容，</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">- refs&#x2F;   &#x2F;&#x2F;目录，存储指向数据的提交对象指针</span></pre></td></tr></table></figure><p>其中<code>HEAD文件</code>，<code>refs目录</code>和<code>objects目录</code>是git能够记录提交历史的关键所在。</p><h3 id="blob-object"><a href="#blob-object" class="headerlink" title="blob object"></a>blob object</h3><p>接下来我们创建两个文件，并通过<code>git add .</code>将修改提交到git暂存区中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">echo &#39;111&#39; &gt; a.txt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">echo &#39;222&#39; &gt; b.txt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">git add .</span></pre></td></tr></table></figure><p>这个时候再去.git/object目录下，你会发现仓库里多了两个文件：</p><p><img src="/images/2020/git1/image-20200604170403533.png" alt="image-20200604170403533"></p><blockquote><p>tree命令： 打印指定目录下的文件结构，mac需要自行安装：<code>brew install tree -g</code></p></blockquote><p>好奇的我们再来打印一下这两个文件里的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cat c2&#x2F;00906</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">cat d5&#x2F;234eb</span></pre></td></tr></table></figure><p><img src="/images/2020/git1/image-20200604170800351.png" alt="image-20200604170800351"></p><p>发现输出了一串乱码，这是因为git将信息压缩成二进制文件，不过没关系git提供<code>cat-file</code>命令来取回转码前的数据，<code>-t</code> 可以查看object文件的类型，<code>-p</code>可以查看object文件的具体内容。</p><blockquote><p>git cat-file [-t] [-p]  object filename   object的名字不用输入全，能唯一区分就好（一般都是6位）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">git cat-file -t c20090</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">git cat-file -p c20090</span></pre></td></tr></table></figure><p><img src="/images/2020/git1/image-20200604171246787.png" alt="image-20200604171246787"></p><p>可以发现这个object文件是一个<code>blob</code>类型的节点，他的内容是”222“，也就是说这个object存储着<code>b.txt</code>文件的内容。</p><p>这是我们遇到的第一种git object：<code>blob</code>，它只存储一个文件的内容，不包含文件名等其他信息。该内容加上特定头部信息一起的 SHA-1 校验和为文件命名，作为这个object在git仓库中的唯一身份证。 校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。</p><p>此时，我们的git仓库长这样：</p><p><img src="/images/2020/git1/image-20200604211814186.png" alt="image-20200604211814186"></p><h3 id="tree-object"><a href="#tree-object" class="headerlink" title="tree object"></a>tree object</h3><p>我们继续探索，在控制台输入<code>git commit -m &#39;feat: 第一次commit&#39;</code>，打印objects文件目录如下：</p><p><img src="/images/2020/git1/image-20200604212656020.png" alt="image-20200604212656020"></p><p>继续<code>cat-file</code>查看新增的两个文件的类型和内容：</p><p><img src="/images/2020/git1/image-20200604212748766.png" alt="image-20200604212748766"></p><p>这里我们遇到了第二个git object类型：<code>tree</code>，它将当前的目录结构打了个快照，从它的存储内容中可以发现它存储了一个目录结构，以及每个文件的模式编号，对应的blob object Hash值，文件名。</p><p>此刻我们的git仓库是这样的：</p><p><img src="/images/2020/git1/image-20200604213736863.png" alt="image-20200604213736863"></p><h3 id="commit-object"><a href="#commit-object" class="headerlink" title="commit object"></a>commit object</h3><p>接着看另一个object文件的内容：</p><p><img src="/images/2020/git1/image-20200604214050940.png" alt="image-20200604214050940"></p><p>至此我们得到了第三个git object类型：<code>commit</code>，它记录了当前项目tree object的Hash，作者/提交者的信息，以及这条commit的提交注释。</p><p>此刻我们的仓库是这样的:</p><p><img src="/images/2020/git1/image-20200604214833936.png" alt="image-20200604214833936"></p><h3 id="HEAD-and-refs"><a href="#HEAD-and-refs" class="headerlink" title="HEAD and refs"></a>HEAD and refs</h3><p>我们再来看下HEAD和refs的内容：</p><p><img src="/images/2020/git1/image-20200604215750564.png" alt="image-20200604215750564"></p><p>refs下存储着你所有分支的当前commit object Hash，HEAD相当于一个指针，指向refs中你当前的分支。</p><p><strong>概括来说整个引用关系就是：HEAD里面的内容是当前分支的ref，而当前ref的内容是commit hash，commit object内容是 tree hash，tree object的内容是blob hash，blob存储着文件的具体内容</strong></p><p><img src="/images/2020/git1/image-20200604220840984.png" alt="image-20200604220840984"></p><p>为了更具象的看一下ref和HEAD指针代表值的含义，我们切换到一个新分支重复我们刚才的操作，控制台输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">echo &#39;333&#39; &gt; a.txt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">git add .</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">git commit -m &#39;feat: 第二次dev提交&#39;</span></pre></td></tr></table></figure><p>可以看到object下又多了三个文件：</p><p><img src="/images/2020/git1/image-20200604220428873.png" alt="image-20200604220428873"></p><p>我们依次输出一下三个文件的内容和类型：</p><p><img src="/images/2020/git1/image-20200604220413262.png" alt="image-20200604220413262"></p><p>依次多了blob object，tree object和commit object，因为我们并没有修改b.text文件的内容，所以仓库里和b.text有关的blob object依旧是之前的那一个。</p><p>再看一下此刻的HEAD和refs下的内容：</p><p><img src="/images/2020/git1/image-20200604220529268.png" alt="image-20200604220529268"></p><p>refs目录下增加了对应的heads/dev文件，记录的是我们新生成的commit object Hash，HEAD里的内容也变成了当前分支：dev。</p><p>此时的仓库为：</p><p><img src="/images/2020/git1/image-20200607103844138.png" alt="image-20200607103844138"></p><h3 id="commit-和-commit"><a href="#commit-和-commit" class="headerlink" title="commit 和 commit"></a>commit 和 commit</h3><p>到这一步，我们已经能弄清楚git是如何保存我们在代码仓库里写的代码，以及如何区分不同分支下的代码是什么样的。下面我们来看一下同一个分支的多个commit记录是怎么关联起来的？</p><p>实际上commit object除了记录当前项目tree object的Hash，还会记录前一次提价的commit object Hash，上面那个例子是因为我们是第一次提交，所以没有对应的记录值。</p><p>在控制台输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">git checkout master</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">echo &#39;444&#39; &gt; a.txt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">git add .</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">git commit -m &#39;feat: 第二次提交&#39;</span></pre></td></tr></table></figure><p>继续打印objects目录下新增的object类容和类型：</p><p><img src="/images/2020/git1/image-20200607104155632.png" alt="image-20200607104155632"></p><p><img src="/images/2020/git1/image-20200607104918776.png" alt="image-20200607104918776"></p><p>可以看到commit的内容里多了一个parent字段，记录了上一次提交的commit object Hash。</p><p>此刻的仓库长这样：</p><p><img src="/images/2020/git1/image-20200607105333667.png" alt="image-20200607105333667"></p><p>通过这种方法，一个分支下的所有提交就能像一个树一样串联起来了。</p><h2 id="git的合并策略"><a href="#git的合并策略" class="headerlink" title="git的合并策略"></a>git的合并策略</h2><p>了解完git是怎么记录提交历史后，我们来了解一下git的合并策略。</p><p>git会有很多合并策略，最常见的几种是 <strong>Fast-foward，Recursice，Ours，Octopus</strong> 。默认git会帮你自动挑选合适的合并策略，也可以通过<code>git merge -s 策略名字</code>来强指定使用的策略类型。</p><h3 id="Fast-foward"><a href="#Fast-foward" class="headerlink" title="Fast-foward"></a>Fast-foward</h3><p><img src="/images/2020/git1/image-20200609213018214.png" alt="image-20200609213018214"></p><p>Fast-foward是最简单的一种合并策略，如图将dev分支合并到master分支上，git只需要将master分支的ref指向最后一个commit节点上：</p><p><img src="/images/2020/git1/image-20200609213826958.png" alt="image-20200609213826958"></p><p>Fast-forward是git在合并两个没有分叉的分支时的默认行为，如果你想禁用掉这种行为，明确拥有一次合并的commit记录，可以使用<code>git merge --no-ff</code>命令来禁用掉。</p><h3 id="Recursive"><a href="#Recursive" class="headerlink" title="Recursive"></a>Recursive</h3><p>Recursive是git中最重要也是最常用的合并策略，简单概述为：通过算法寻找两个分支的最近公共祖先节点，再将找到的公共祖先节点作为base节点使用三向合并的策略来进行合并。</p><p>举个例子：圆圈里的字母为当前commit中的内容，当我们要合并2，3两个分支时，先找到他们的公共祖先节点1，接着和节点1的内容进行对比，因为1的内容是A，所以2并没有修改内容，而3将内容改成B，所以最后的合并结果的内容也是B。</p><p><img src="/images/2020/git1/image-20200614221411190.png" alt="image-20200614221411190"></p><p>但实际的情况总是复杂的多的，会出现几个分支相互交叉的情况（Criss-Cross现象）</p><p><img src="/images/2020/git1/image-20200614222236747.png" alt="image-20200614222236747"></p><p>如上图所示，当我们在寻找最近公共祖先时，可以找到两个节点：节点2和节点3。</p><p>如果我们以节点2作为base节点，如下图：</p><p><img src="/images/2020/git1/image-20200614232900025.png" alt="image-20200614232900025"></p><p>此时通过三向合并策略合并（base节点的内容是A，两个待合并分支节点的内容是B和C）我们是无法得出应该使用哪个节点内容的，需要自己手动解决冲突。</p><p>而如果使用节点3作为base节点，那么通过三向合并策略合并（base节点的内容是B，两个待合并分支节点的内容是B和C）可以得出应该使用C来作为最终结果：</p><p><img src="/images/2020/git1/image-20200614233646738.png" alt="image-20200614233646738"></p><blockquote><p>查看两个分支的最近公共祖先可以使用命令：<code>git merge-base --all branch_1 branch_2</code></p></blockquote><p>作为人类，其实我们很容易看出正确的合并结果应该是C，那么git要如何保证自己能找到正确的base节点，尽可能的减少代码的合并冲突呢？</p><p>实际上git在合并时，如果查找发现满足条件的祖先节点不唯一，那么git会首先合并满足条件的祖先节点们，将合并完的结果作为一个虚拟的base节点来参与接下来的合并。</p><p>如下图：git会首先合并节点2和节点3，找到他们的公共祖先节点1，在通过三项合并策略得到一个虚拟的节点8，内容是B，再将节点8作为base节点，和节点5，节点6合并，比较完后得出最终版本的内容应该是C。</p><p><img src="/images/2020/git1/image-20200614234812708.png" alt="image-20200614234812708"></p><p><strong>Ours &amp; Theirs参数</strong></p><p>在合并时我们可以带上<code>-Xours</code>， <code>-Xtheirs</code>参数，表明合并遇到冲突时自动选择使用其中一方的更改。如下图在master分支下执行<code>git merge -Xours dev</code>，最后产生的节点内容将自动采取master分支上的内容而不需要你再手动解决冲突。</p><p><img src="/images/2020/git1/image-20200615135704299.png" alt="image-20200615135704299"></p><p><code>-Xtheirs</code>参数和<code>-Xours</code>完全相反，遇到冲突时他会自动采取dev上的内容。<strong>注意这两个参数只有遇到冲突时才会生效，这和我们下面提到的Ours策略不一样</strong></p><h3 id="Ours"><a href="#Ours" class="headerlink" title="Ours"></a>Ours</h3><p>Ours 策略和上文提到的<code>-Xours</code>参数非常相像，不同的是<code>-Xours</code>参数是只有合并遇到冲突时，git会自动丢弃被合并分支的更改保留原有分支上的内容，如果没有冲突，git还是会帮我们自动合并的。</p><p>而Ours策略是无论有没有冲突，git都会完全丢弃被合并分支上的内容，只保留合并分支的上的修改，只是在commit的记录上会保留另一个分支的记录。</p><p> 如下图在master分支下执行<code>git merge -s ours dev</code>，最后产生的合并节点其内容和master分支上一个节点完全一样。</p><p><img src="/images/2020/git1/image-20200615140457561.png" alt="image-20200615140457561"></p><p>这种策略的应用场景一般是为了实现某个功能，同时尝试了两种方案，最终决定选择其中一个方案，而又希望把另一个方案的commit记录合进主分支里方便日后的查看。</p><h3 id="为什么没有Theirs策略"><a href="#为什么没有Theirs策略" class="headerlink" title="为什么没有Theirs策略"></a>为什么没有Theirs策略</h3><p>既然合并的时候即有<code>-Xtheirs</code>参数又有<code>-Xours</code>参数，所以下意识的觉得git即有 Ours 策略也会有 Theirs 策略，实际上git曾经有过这个策略后来舍弃了，因为Theirs会完全丢掉当前分支的更改，是一个十分危险的操作，如果你真的想丢弃掉自己的修改，可以使用reset命令来代替它。</p><h3 id="Octopus"><a href="#Octopus" class="headerlink" title="Octopus"></a>Octopus</h3><p>Octopus 策略可以让我们优雅的合并多个分支。前面我们介绍的策略都是针对两个分支的，如果现在有多个分支需要合并，使用Recursive策略进行两两合并会产生大量的合并记录：每合并其中两个分支就会产生一个新的记录，过多的合并提交出现在提交历史里会成为一种“杂音“，对提交历史造成不必要的”污染“。</p><p> Octopus在合并多个分支时只会生成一个合并记录，这也是git合并多个分支的默认策略。如下图：在master分支下执行<code>git merge dev1 dev2</code>：</p><p><img src="/images/2020/git1/image-20200615211642325.png" alt="image-20200615211642325"> </p><h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><p>看完git merge 的策略后，再看看另一个合并代码时常用的命令git rebase。git rebase和merge最大的不同是它会改变提交的历史。</p><p>如下图：在dev上rebase master时，git会以master分支对应的commit节点作为起点，将dev上commit节点“平移”至master commit的后面，并且会创建全新的commit节点来替代之前commit：</p><p><img src="/images/2020/git1/image-20200616102604450.png" alt="image-20200616102604450"></p><p>接下来我们再来看一下“平移”的过程中git需要做的事情：首先我们需要以commit5作为base节点，commit1和commit6进行合并生成新的commit3，然后再将commit3的parent指向commit6。commit2到commit4转变进行了同样的步骤。因为相比较之前的commit，新的commit的parent变了，对应的hash值自然也变了。</p><p>所以我们在rebase的时候，你当前分支有几个commit记录那么git就需要进行合并几次。如果你当前分支比较”干净“，只有一个commit记录的话，那么你rebase需要解的冲突其实和merge是一样的，区别就是rebase不会单独生成一个新的commit来记录这次合并。</p><p>关于<code>git pull master --rebase</code>和<code>git rebase master</code>的区别：git pull –rebase相当于git fetch + git rebase，正常的git pull相当于git fetch + git merge。</p><p>至于什么时候用rebase什么时候用merge，我的理解是：开发只属于自己的分支时尽量使用rebase，减少无用的commit合到主分支里，多人合作时尽量使用merge，一方面减少冲突，另一个方面也让每个人的提交有迹可循。</p><p>git rebase还有一个功能是可以合并commit记录：<code>git rbase -i HEAD~n</code>。合并分支还有一个办法是<code>git merge --squash</code>，区别是merge –squash会将你之前所有的记录压缩成一个新的commit，而rebase具体要怎么压缩的可操作性比较高，这里就不多展开论述了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后我们来看一个新手合并代码经常会遇到的问题：</p><p>小明在他的开发分支上完成了一个开发功能并且合上了master分支，后来发现新开发的代码有点问题，于是小明执行了revert操作：将master需要回退到没有合并时的版本，并继续在之前的开发分支上修复了问题：</p><p><img src="/images/2020/git1/image-20200616213819692.png" alt="image-20200616213819692"></p><p>这个时候他再试图把dev分支往master上合并时，会发现B节点上新增的内容莫名其妙的就丢失了。根据git的合并策略我们就很容里理解这个问题：</p><p>在合并两个有分叉的分支（上图中的D和A^），git会默认选择Recursive策略来进行合并，对于D和A^他们的最近父节点是B，以B为base节点，对D和A^做三项合并，B中拥有“B”的内容，D中也拥有“B”的内容，A^中将“B”的内容丢弃，所以合并的结果就是将“B”的内容丢弃。</p><p>根据原理解决的方案也有很多，最简单的一种在节点D合并A^前，先revert一下生成A^^（revert的revert），再继续合并就没问题了，或者修复问题时从A^节点单独拉一个新分支修复，而不是在之前dev分支上继续开发。</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v8对象属性的存储结构</title>
      <link href="/2020/04/26/2020/v8%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
      <url>/2020/04/26/2020/v8%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>先从一个简单的例子看起，我们在控制台输入下面这段代码并执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="string">'c'</span>:<span class="string">'c'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="string">'d'</span>:<span class="string">'d'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="string">'b'</span>:<span class="string">'b'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="number">2</span>:<span class="number">2</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span>:<span class="number">1</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="string">'a'</span>:<span class="string">'a'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span>:<span class="number">3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(foo)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//结果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>]</span></pre></td></tr></table></figure><h2 id="Element-Property"><a href="#Element-Property" class="headerlink" title="Element, Property"></a>Element, Property</h2><p>可以看出来属性的遍历结果和我们定义对象时设置的顺序并不一样：我们是乱序设置属性的，但打印的结果却十分的有规律，事实上这是 <a href="https://tc39.es/ecma262/#sec-ordinaryownpropertykeys" target="_blank" rel="noopener">ECMA规范</a> 制定的结果，总结起来如下：</p><ul><li>先打印出数字这种索引类型的属性，再打印出字符串这种常规类型的属性</li><li>索引类型的属性（下文称为索引属性）按照索引值从小到大的顺序打印出来</li><li>常规类型的属性（下文称为常规属性）按照创建时间的先后顺序打印出来</li></ul><p>从这个规律里也不难判断出，V8在存储对象的属性时，索引属性和常规属性是分开来存储的，事实上也正是如此，<strong>索引属性被放在对象的elements属性下面，常规属性被放在对象的properties属性下面</strong>。分解成这两个结构后，如果执行遍历对象的操作，那么 V8 会先从 elements 属性中按照顺序读取所有的元素，然后再从 properties 属性中读取所有的元素，这样就完成一次遍历操作。</p><p>执行下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name, property_num=<span class="number">0</span>, element_num=<span class="number">0</span></span>) </span>&#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//添加可索引属性 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; element_num; i++) &#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>[i] = <span class="string">`element<span class="subst">$&#123;i&#125;</span>`</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//添加常规属性 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; property_num; i++) &#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> ppt = <span class="string">`property<span class="subst">$&#123;i&#125;</span>`</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>[ppt] = ppt </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo(<span class="string">'a'</span>, <span class="number">3</span>, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Foo(<span class="string">'b'</span>, <span class="number">3</span>, <span class="number">3</span>)</span></pre></td></tr></table></figure><p>在Chrome控制台下打开<strong>Memory</strong>面板，生成一个<strong>新快照</strong>。在搜索框里输入<strong>构造函数Foo</strong>，Chrome 会列出所有经过构造函数 Foo 创建的对象，如下图所示</p><p><img src="/images/2020/v8/image-20200421183723593.png" alt="image-20200421183723593"></p><p><img src="/images/2020/v8/image-20200426145348796.png" alt="image-20200426145348796"></p><p>在上面这段代码里，我们给对象a设置了3个常规属性property0，property1，property2，给对象b设置了3个常规属性property0，property1，property2和3个索引属性element0，element1，element2。</p><p>在快照里能很明显看出，b的索引属性被放在elements下面。此外细心的小伙伴可以看出，这两个对象的结构描述Map（Hidden Class）是一样的（框框圈出的部分），但是明明a，b的name属性不一样，且对象b比对象a多出了3个索引属性，他们的描述结构怎么会是一样呢？</p><h2 id="Hidden-Class"><a href="#Hidden-Class" class="headerlink" title="Hidden Class"></a>Hidden Class</h2><p>我们都知道，像 Java 这样的静态语言，类型一但创建便不可更改，属性可以通过固定的偏移量进行访问。相比之下，JavaScript 是一个动态类型的语言，对象创建之后可以在运行时改变类型，添加或删除属性，这意味着属性的类型和内存偏移量只有在运行时才能确定。</p><p>为了解决动态查找属性的问题，JavaScript 中引入了 Hidden Class（隐藏类，在V8中被称作Map）的概念：每当一个属性的值发生改变时，我们就会重新计算这个属性的内存偏移量并把他记录在 Hidden Class 里。</p><p>先说明几个隐藏类的特性：</p><ul><li>每个对象都拥有自己的隐藏类</li><li>隐藏类中记录了对象中每个属性的内存偏移量</li><li>当对象创建一个新属性，或者一个老属性被删除时，V8会创建一个新的隐藏类并通过<strong>back_pointer</strong>指针指向老的隐藏类，新的隐藏类中只记录进行了变更的属性信息，随后对象指向隐藏类的指针会指向新的隐藏类</li><li>对象创建一个新属性时，会检查该对象隐藏类的<strong>转换信息（transition information）</strong>。如果转换信息包含了与当前属性更改相同的条件，则对象会将其隐藏类变更为转换信息中记录的类，而不会再创建一个新的隐藏类。</li></ul><p>下面几个具体的例子来说明对象中隐藏类的创建：</p><h3 id="特性3：链式创建"><a href="#特性3：链式创建" class="headerlink" title="特性3：链式创建"></a>特性3：链式创建</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hiddenClass = <span class="keyword">new</span> Foo(<span class="string">'hiddenClass'</span>)</span></pre></td></tr></table></figure><p><img src="/images/2020/v8/image-20200422154200163.png" alt="image-20200422154200163"></p><p>图上可以看出Hidden Class的隐藏类标记是：Map @621063。</p><p>下面给hiddenClass添加一个新的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">hiddenClass.a = <span class="string">'a'</span></span></pre></td></tr></table></figure><p><img src="/images/2020/v8/image-20200422154848924.png" alt="image-20200422154848924"></p><p>hiddenClass有了一个新的隐藏类Map @621537，同时他的back_pointer指针指向上一个隐藏类Map @621063。</p><h3 id="特性4：相同隐藏类"><a href="#特性4：相同隐藏类" class="headerlink" title="特性4：相同隐藏类"></a>特性4：相同隐藏类</h3><p>还记得前面遗留的问题嘛：两个不同的对象，拥有不同的属性但是却拥有相同的Hidden Class。</p><p>首先要明确一点的是，每个对象都有自己的elements属性，指向element对象，默认情况下这个对象是线性存储数据的，对于a和b这两个对象来说，他们的elements对象的类型是一样的。那自然Hidden Class不需要单独对element做特殊记录。</p><p>当然，如果element的存储结构发生改变，Hidden Class自然也会发生改变。执行下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">a[<span class="number">1111</span>] = <span class="string">`element<span class="subst">$&#123;<span class="number">1111</span>&#125;</span>`</span></span></pre></td></tr></table></figure><p><img src="/images/2020/v8/image-20200426145905931.png" alt="image-20200426145905931"></p><p>可以看到，a的Hidden Class发生了改变，它的elements属性下的数据存放也没有规律了。这是因为，当我们添加了 <code>a[1111]</code> 之后，数组会变成稀疏数组。为了节省空间，稀疏数组会转换为哈希存储的方式，而不再是用一个完整的数组描述这块空间的存储。所以，这几个可索引属性也不能再直接通过它的索引值计算得出内存的偏移量，需要在Hidden Class里记录对应的信息。</p><p>下面再来分析一下为什么a和b的name不同但是拥有相同的Hidden Class。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name, property_num=<span class="number">0</span>, element_num=<span class="number">0</span></span>) </span>&#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//添加可索引属性 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; element_num; i++) &#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>[i] = <span class="string">`element<span class="subst">$&#123;i&#125;</span>`</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//添加常规属性 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; property_num; i++) &#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> ppt = <span class="string">`property<span class="subst">$&#123;i&#125;</span>`</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>[ppt] = ppt </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo(<span class="string">'a'</span>, <span class="number">3</span>, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Foo(<span class="string">'b'</span>, <span class="number">3</span>, <span class="number">3</span>)</span></pre></td></tr></table></figure><p>当我们执行<code>var a = new Foo(&#39;a&#39;, 3, 0)</code>这段代码时，隐藏类的信息概括如下：</p><ul><li><p>Hidden Class <code>c0</code></p><ul><li>没有其他属性的内存偏移量（空对象）</li><li>转换信息：如果对象要添加<code>name</code>属性，那么应该引用 Hidden Class <code>c1</code></li></ul></li><li><p>Hidden Class <code>c1</code></p><ul><li><code>name</code>属性的内存偏移量</li><li>back_pointer：Hidden Class <code>c1</code></li><li>转换信息：如果对象要添加property1，那么应该引用 Hidden Class <code>c2</code></li></ul></li><li><p>Hidden Class <code>c2</code></p><p>……</p></li><li><p>Hidden Class <code>cn</code></p><ul><li><code>name</code>and<code>property0-n</code>属性的内存偏移量</li><li>back_pointer: Hidden Class <code>cn-1</code></li></ul></li></ul><p>对象a生成完毕，开始执行``var b = new Foo(‘b’, 3, 3)`。</p><p>b创建成功并且绑定了隐藏类<code>c0</code>，这时要往里面添加name属性了，发现<code>c0</code>的转换信息里记录了一条：如果要添加name属性，那么应该引用Hidden Class  <code>c1</code>，和我们的操作正好相同，所以我们无需再创建新的隐藏类而直接引用<code>c1</code>就可以了，这也是为什么a和b的name不同但是他们的Hidden Class相同。</p><p>另外小伙伴们肯定也发现了，索引属性能看到放在element属性下，可是常规属性并没有放在property属性下，而是直接披露在对象本身下面的，这是因为V8为了能够快速的查找出属性值，对常规属性的存储采取了一系列权衡策略。</p><h2 id="对象内属性，快属性，慢属性"><a href="#对象内属性，快属性，慢属性" class="headerlink" title="对象内属性，快属性，慢属性"></a>对象内属性，快属性，慢属性</h2><p>V8中命名属性有三种存储方式：对象内属性（in-object），快属性（fast）和慢属性（slow)。</p><p>对象内属性是直接存储到对象本身的，提供最快的查找速度。</p><p>快属性比对象内属性多了一次寻址时间：先查找出 properties 属性所指向的对象 properties ，之后可以直接根据偏移量查找的</p><p>慢属性比起前面两种，会存储属性的完整结构（前面两种的属性结构会在隐藏类里概括），速度最慢。</p><p><img src="/images/2020/v8/image-20200422104609594.png" alt="image-20200422104609594"></p><p>这么说可能比较抽象，我们直接执行下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Foo(<span class="number">13</span>, <span class="number">3</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> Foo(<span class="number">99</span>, <span class="number">3</span>)</span></pre></td></tr></table></figure><p><img src="/images/2020/v8/image-20200412220737458.png" alt="image-20200412220737458"></p><p>我们创建了一个拥有13个常规属性和3个索引属性的对象c，在内存快照中能看到properties下面有三条属性记录：’property10’，’property11’，’property12’，剩下的property0-9直接放到对象本身下了。</p><p>对象在存储常规属性时，优先按照对象内属性来存储，只不过对象内属性空间有限（一般是10个），超出的部分就放到properties对象下存储了。</p><p>在属性比较少时，properties默认按照线性存储，在对象比较多时，会替换成Hash存储，如例子中的对象d所示：</p><p><img src="/images/2020/v8/image-20200412220756620.png" alt="image-20200412220756620"></p><p>替换成Hash的原因是：当属性量比较多时，快属性的访问可能就没有慢属性快了。</p><p>假设哈希运算的代价为 30 次简单位运算，如果只用快属性的方式存储，当我需要访问第 99 个属性，就需要 99 次简单位运算。而使用慢属性，我们需要一次哈希计算（30 次简单位运算）+ 第二维的线性比较（远小于 30 次，已假设哈希算法表现良好，那属性在哈希表中是均匀分布的），显然使用hash可以让我们更快的获取属性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>遍历一个对象的属性时，先按照索引大小遍历索引属性，再按照创建时间的先后顺序遍历常规属性</li><li>索引属性统一存储在对象的elements属性对象下面，常规属性按照先存放在对象内属性，超出部分存储在properties属性对象下面的规律存放</li><li>elements和properties属性对象的存储结构会按照实际场景选择线性存储还是Hash存储</li><li>对象通过Hidden Class来实现动态查找属性</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo快速搭建个人博客(二) -- 部署篇</title>
      <link href="/2020/03/17/2020/%E5%9F%BA%E4%BA%8EHexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A22/"/>
      <url>/2020/03/17/2020/%E5%9F%BA%E4%BA%8EHexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A22/</url>
      
        <content type="html"><![CDATA[<p>上一篇里，你已经能在你的本地跑起一个localhost的项目了，那么，怎么让你的项目别人也能访问到呢，如何绑定自定义域名以及让各大搜索引擎能搜索到自己的博客呢？</p><h2 id="github-pages-coding-pages"><a href="#github-pages-coding-pages" class="headerlink" title="github pages / coding pages"></a>github pages / coding pages</h2><blockquote><p> 感谢这些免费且便捷的托管工具</p></blockquote><ol><li>首先，我们在github上新建一个项目，用来存储我们的博客代码：</li></ol><p><img src="/images/2020/image-20200317181846915.png" alt="image-20200317181846915"></p><ol start="2"><li>接下来在项目的_config.yml文件里，把我们新创建的项目地址配置好，这样后面运行hexo的命令行时就可以自动的把我们本地代码推到托管平台上了：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">deploy:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  type: &#39;git&#39;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  repository:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    github: &#39;https:&#x2F;&#x2F;github.com&#x2F;includeios&#x2F;includeios.github.io.git&#39;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    coding: &#39;git@e.coding.net:atangge_tripod&#x2F;atangge_tripod.git&#39;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  branch: master</span></pre></td></tr></table></figure><p>这里我分别配置了github和coding</p><ol start="3"><li>生成静态资源和推送网站</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">hexo clean </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">hexo g </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">hexo d</span></pre></td></tr></table></figure><ol start="4"><li><p>在项目里开启github page选项</p><p><img src="/images/2020/image-20200317182450897.png" alt="image-20200317182450897"></p><p>往下滚，找到Github Pages选项，将Source改为master branch，最后点击Save按钮</p></li></ol><p><img src="/images/2020/image-20200317182639804.png" alt="image-20200317182639804"></p><p>Ok，此刻你在地址栏里输入：<a href="http://username.github.io（username是你github的名字），就能看到你的博客页面拉。" target="_blank" rel="noopener">http://username.github.io（username是你github的名字），就能看到你的博客页面拉。</a></p><p>coding上的部署和github类似，不同的是他会生成一个随机字符作为你静态页面的访问地址，不过比起github，国内网访问coding的静态网站会更快点。</p><h2 id="绑定自定义域名"><a href="#绑定自定义域名" class="headerlink" title="绑定自定义域名"></a>绑定自定义域名</h2><p>假设你已经花了几百大洋拥有一个属于自己的域名，还没有买的小伙伴可以去腾讯云或者阿里云上买一个。</p><p>阿里云购买传送桶：<a href="https://wanwang.aliyun.com/domain/" target="_blank" rel="noopener">https://wanwang.aliyun.com/domain/</a></p><blockquote><p>这个文章的域名 tripod.fun 提取关键字<strong>阿汤哥的鼎</strong>中的<strong>鼎</strong>！！！翻译来的….</p><p>199，10年，199，你买不来吃亏，买不了上当</p></blockquote><p>接下来在你的控制台输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">ping username.github.io（github上你的域名&#x2F;coding上你的域名）</span></pre></td></tr></table></figure><p>就能看到你的网站的ip地址了：</p><p><img src="/images/2020/image-20200317224700951.png" alt="image-20200317224700951"></p><p>接下来我们回到购买域名的平台中心，在域名解析里面添加上我们刚刚得到的ip地址</p><p><img src="/images/2020/image-20200317224940477.png" alt="image-20200317224940477"></p><p>接下来返回github page，在Custom domain里面添加上透露着金钱味道的域名就好啦~</p><p><img src="/images/2020/image-20200317225211367.png" alt="image-20200317225211367"></p><h2 id="在各大搜索引擎里添加站点"><a href="#在各大搜索引擎里添加站点" class="headerlink" title="在各大搜索引擎里添加站点"></a>在各大搜索引擎里添加站点</h2><p>直接在百度里面搜索我们新绑定的域名，他会提醒你要不要收录这个地址</p><p><img src="/images/2020/image-20200317225448788.png" alt="image-20200317225448788"></p><p>点击链接提交完后，这个网址百度就会记录啦</p><p>不过我们博客一般不会只有这一条链接，像我的博客<a href="http://www.tripod.fun/，每篇文章都会有属于自己的url地址，如果没写一篇文章都要手动添加一下岂不是很麻烦。" target="_blank" rel="noopener">http://www.tripod.fun/，每篇文章都会有属于自己的url地址，如果没写一篇文章都要手动添加一下岂不是很麻烦。</a></p><p>百度提供了认证主站后，后面的子站都可以自动收录的功能，有三种方法，这里推荐用文件验证：</p><p><img src="/images/2020/image-20200317225917043.png" alt="image-20200317225917043"></p><p>按照提示下载好文件，放到source下面，重新运行一下构建命令行，就能看到构建好的代码根目录下有对应的html文件：</p><p><img src="/images/2020/image-20200317230554497.png" alt="image-20200317230554497"></p><p>google与百度同理，</p><p>google的站点管理页面传送桶：<a href="https://search.google.com/search-console/links?resource_id=https%3A%2F%2Fincludeios.github.io%2F&amp;hl=zh-CN" target="_blank" rel="noopener">https://search.google.com/search-console/links?resource_id=https%3A%2F%2Fincludeios.github.io%2F&amp;hl=zh-CN</a></p><p>欧卡！push完代码后，再过几天让两大搜索引擎的爬虫亲密光顾你的博客内容一阵子，你就能在搜索引擎上搜索到你自己啦</p><p><img src="/images/2020/image-20200317230738177.png" alt="image-20200317230738177"></p><p>从此以后，爷也是在江湖上留下过脚印的人…</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo快速搭建个人博客(一) -- 项目篇</title>
      <link href="/2020/01/28/2020/%E5%9F%BA%E4%BA%8EHexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A21/"/>
      <url>/2020/01/28/2020/%E5%9F%BA%E4%BA%8EHexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A21/</url>
      
        <content type="html"><![CDATA[<p>每一个写博客的同学应该都想过搭建属于自己的博客平台，但是从零到有开发一个个人平台又实在太麻烦，所以大部分情况下我们都将自己的文章托管到一个内容平台：github或者知乎专栏。</p><p>后来同事推荐了<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>这款小利器，支持markdown，一键部署等强大功能，同时拥有丰富的主题，也是阮老师博客使用的框架，总之，你值得拥有。</p><h2 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h2><p>我的博客地址：<a href="http://0u6edk.coding-pages.com/" target="_blank" rel="noopener">阿汤哥的鼎出品</a></p><p><img src="/images/2020/%E5%9F%BA%E4%BA%8EHexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A21-1.png" alt="image-20200128165122498"></p><p><img src="/images/2020/%E5%9F%BA%E4%BA%8EHexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A21-2.png" alt="image-20200128161613759"></p><p>Hexo帮我们实现了大部分博客需要的功能：合理的布局样式，导航条和文章列表……</p><p>我们也可以添加一些自定义的功能，比如我添加的小埋动画，文章标题的搜索，后面会详细介绍这些功能的实现，本篇主要介绍项目搭建这部分内容。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span></pre></td></tr></table></figure><p>so easy……，当然，默认你已经有了node环境。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>安装好了后，执行以下几条命令，hexo会在指定文件夹下帮你生成建站需要的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$ cd &lt;folder&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">$ npm install</span></pre></td></tr></table></figure><p>此时指定文件夹下会有如下目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">├── _config.yml      # 配置文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">├── package.json</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">├── scaffolds        # 模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">├── source           # 资源文件夹，下面的&#39;_&#39;开头的文件夹对应着scaffolds下的模板</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">|   ├── _drafts</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">|   └── _posts</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">└── themes           # 主题文件夹， Hexo 会根据主题来生成静态文件</span></pre></td></tr></table></figure><h2 id="选择自己喜欢的主题"><a href="#选择自己喜欢的主题" class="headerlink" title="选择自己喜欢的主题"></a>选择自己喜欢的主题</h2><p>将大象放到冰箱需要3步：第一步：打开冰箱，第二步：将大象放进去，第三步：关上冰箱。</p><p>Hexo设置一个主题也需要3步：第一步：选择一个你喜欢的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a>，第二步：去对应的github地址下载到themes文件夹下，第三步：将_config.yml下的theme配置成新主题的名字。</p><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>建站傻白甜到让我不知道该说些什么…</p><p>修改_config.yml配置，什么导航条目录呀，使用主题呀，等信息都可以在<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置文档</a>上找到相应的api。</p><p>在scaffolds文件夹下生产一个模板文件，模板的配置请参考：<a href="https://hexo.io/zh-cn/docs/templates" target="_blank" rel="noopener">模板</a></p><p>在source对应的文件夹下将你写好的md文章拖进去，运行 <code>hexo serve</code>, OK了…</p><p>不过Hexo这么方便的代价就是有很多的配置api，需要仔细阅读配置文档找相应的功能，好在即使Hexo没有提供你想要的功能也可以通过插件等方式添加进去。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>ok，此刻你已经在你的localhost下看到了一个漂漂亮亮的网站了，后面会介绍如何通过github/coding代码托管工具生成可访问的静态页面，绑定自定义域名以及如何让各大搜索引擎能搜索到自己的博客。</p><p>朋友们新春快乐，下期见。</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于vue搭建pwa应用（一）</title>
      <link href="/2019/11/22/2019/%E5%9F%BA%E4%BA%8Evue%E6%90%AD%E5%BB%BApwa%E5%BA%94%E7%94%A81/"/>
      <url>/2019/11/22/2019/%E5%9F%BA%E4%BA%8Evue%E6%90%AD%E5%BB%BApwa%E5%BA%94%E7%94%A81/</url>
      
        <content type="html"><![CDATA[<p>本篇不做pwa相关的技术分享，只是记录一些自己搭建时遇到的问题供以后查阅。关于pwa的技术分享：<a href="https://juejin.im/post/5a6c86e451882573505174e7" target="_blank" rel="noopener">https://juejin.im/post/5a6c86e451882573505174e7</a> 这篇文章总结的挺好的，例子也很不错。</p><h2 id="实现效果一览"><a href="#实现效果一览" class="headerlink" title="实现效果一览"></a>实现效果一览</h2><ol><li><h4 id="添加到主屏幕"><a href="#添加到主屏幕" class="headerlink" title="添加到主屏幕"></a>添加到主屏幕</h4></li></ol><p><img src="https://user-images.githubusercontent.com/18004081/69401690-af5e3700-0d30-11ea-8b9f-59317aa8884e.jpg" alt="241574393822_ pic"><br><img src="https://user-images.githubusercontent.com/18004081/69401716-bedd8000-0d30-11ea-96ad-80b4e1d92cff.jpg" alt="231574393777_ pic"></p><ol start="2"><li><h4 id="离线应用-离线时也能正常访问页面"><a href="#离线应用-离线时也能正常访问页面" class="headerlink" title="离线应用 : 离线时也能正常访问页面"></a>离线应用 : <a href="https://bytedance.feishu.cn/space/file/boxcnlFmk1n4P3GKjz6amKZtyLb" target="_blank" rel="noopener">离线时也能正常访问页面</a></h4></li><li><h4 id="服务器推送消息"><a href="#服务器推送消息" class="headerlink" title="服务器推送消息"></a>服务器推送消息</h4></li></ol><p><img src="https://user-images.githubusercontent.com/18004081/69402146-eaad3580-0d31-11ea-8c3c-85503595ab3c.jpg" alt="201574393752_ pic"></p><h2 id="1-模拟https环境"><a href="#1-模拟https环境" class="headerlink" title="1.模拟https环境"></a>1.模拟https环境</h2><p>Service Worker 只能运行在localhost或者https环境下，你可以跑个本地服务试一试，或者代理个线上https环境</p><ul><li>本地build，生成dist目录</li><li>根据dist路径起个nginx服务</li><li>将线上的静态资源代理到本地nginx服务</li></ul><h2 id="2-保存到主屏幕：manifest"><a href="#2-保存到主屏幕：manifest" class="headerlink" title="2.保存到主屏幕：manifest"></a>2.保存到主屏幕：manifest</h2><p>manifest可以配置应用程序安装到设备主屏幕时的icon，开屏动画，第一次进入地址等，例子里说的很详细，不详细展开了，具体配置可参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/Manifest" target="_blank" rel="noopener">MDN</a>。</p><p>beforeinstallprompt的官方解释，他将会在一个<strong>合适的时间提醒用户保存到主屏幕</strong>时触发，这个<strong>合适</strong>的sao操作大家自行感受一下。</p><h2 id="3-离线缓存：ServiceWorker"><a href="#3-离线缓存：ServiceWorker" class="headerlink" title="3.离线缓存：ServiceWorker"></a>3.离线缓存：ServiceWorker</h2><p>官网推荐使用：<a href="https://stackoverflow.com/questions/35780397/understanding-service-worker-scope" target="_blank" rel="noopener">Workbox</a></p><h4 id="首先在项目中注册Service-Worker："><a href="#首先在项目中注册Service-Worker：" class="headerlink" title="首先在项目中注册Service Worker："></a><strong>首先在项目中注册Service Worker：</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    navigator.serviceWorker.register(<span class="string">'/mobile/service-worker.js'</span>,&#123;<span class="attr">scope</span>:<span class="string">'/mobile'</span>&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .then(<span class="function">(<span class="params">reg</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Service Worker registered! '</span>, reg);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      <span class="built_in">console</span>.error(<span class="string">'Service Worker register error: '</span>, err);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><ul><li>register第一个传参是Service Worker的脚本的url地址，注意是可访问的url地址，而不是相对路径</li><li>Service Worker只会拦截在scope作用域下的请求，scope会在注册时生成（默认为Service Worker的location），你只能设置为Service Worker所在的根目录以及他子集，所以一般把生成的Service Worker放到根目录下</li></ul><h4 id="配置workbox实现离线缓存"><a href="#配置workbox实现离线缓存" class="headerlink" title="配置workbox实现离线缓存"></a><strong>配置workbox实现离线缓存</strong></h4><p>目前比较粗糙，静态资源和接口都缓存下来了，Workbox有好几种缓存策略，比较方便配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态资源预缓存</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">workbox.precaching.precacheAndRoute(self.__precacheManifest || []);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态资源</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">workbox.routing.registerRoute(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  /(?:\/overview|\.js|\.css)$/,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">new</span> workbox.strategies.StaleWhileRevalidate(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    cacheName: <span class="string">'static-cache'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图片缓存</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">workbox.routing.registerRoute(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  /\.(?:png|jpg|jpeg|svg|gif)$/,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">new</span> workbox.strategies.CacheFirst(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Use a custom cache name.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    cacheName: <span class="string">'image-cache'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    plugins: [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">new</span> workbox.expiration.Plugin(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Cache for a maximum of a week.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        maxAgeSeconds: <span class="number">7</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">      &#125;),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    ],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口缓存</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">workbox.routing.registerRoute(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  /\/v\/api/,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">new</span> workbox.strategies.NetworkFirst(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    cacheName: <span class="string">'api-cache'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">);</span></pre></td></tr></table></figure><h4 id="Webpack的workbox插件"><a href="#Webpack的workbox插件" class="headerlink" title="Webpack的workbox插件"></a><strong>Webpack的workbox插件</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WorkboxPlugin = <span class="built_in">require</span>(<span class="string">'workbox-webpack-plugin'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"> <span class="keyword">new</span> WorkboxPlugin.InjectManifest(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   swSrc: <span class="string">'src/pages/author/service-worker.js'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">   swDest: <span class="string">'service-worker.js'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"> &#125;),</span></pre></td></tr></table></figure><h2 id="4-服务端主动推送消息"><a href="#4-服务端主动推送消息" class="headerlink" title="4.服务端主动推送消息"></a>4.服务端主动推送消息</h2><p>这篇文章解释的挺好的：<a href="https://www.jianshu.com/p/9970a9340a2d" target="_blank" rel="noopener">https://www.jianshu.com/p/9970a9340a2d</a></p><h4 id="注册Service-Worker时订阅push-service"><a href="#注册Service-Worker时订阅push-service" class="headerlink" title="注册Service Worker时订阅push service"></a><strong>注册Service Worker时订阅push service</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> applicationServerPublicKey = <span class="string">'BMz9tUR-Iq3W2K0u1fy0qb5p1zD65s7N0laipwmuq7yefjASIkbrFUXKjmEmayOClvCdc0ytiLSblU1UGTnSmkY'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">urlB64ToUint8Array</span>(<span class="params">base64String</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> padding = <span class="string">'='</span>.repeat((<span class="number">4</span> - base64String.length % <span class="number">4</span>) % <span class="number">4</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> base64 = (base64String + padding)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .replace(<span class="regexp">/\-/g</span>, <span class="string">'+'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    .replace(<span class="regexp">/_/g</span>, <span class="string">'/'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> rawData = <span class="built_in">window</span>.atob(base64);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> outputArray = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(rawData.length);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rawData.length; ++i) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    outputArray[i] = rawData.charCodeAt(i);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> outputArray;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribeUserToPush</span>(<span class="params">registration</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> subscribeOptions = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    userVisibleOnly: <span class="literal">true</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    applicationServerKey: urlB64ToUint8Array(applicationServerPublicKey),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> registration.pushManager.subscribe(subscribeOptions).then(<span class="function"><span class="keyword">function</span> (<span class="params">pushSubscription</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Received PushSubscription: '</span>, <span class="built_in">JSON</span>.stringify(pushSubscription));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> pushSubscription;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendSubscriptionToServer</span>(<span class="params">subscription</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/subscription?subscription='</span> + <span class="built_in">JSON</span>.stringify(subscription));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    navigator.serviceWorker.register(<span class="string">'/mobile/service-worker.js'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    .then(<span class="function">(<span class="params">reg</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Service Worker registered! '</span>, reg);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">return</span> subscribeUserToPush(reg);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    .then(<span class="function">(<span class="params">subscription</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (subscription) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(<span class="string">'User is subscribed'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        sendSubscriptionToServer(subscription);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">console</span>.error(<span class="string">'User is not subscribed!'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">      <span class="built_in">console</span>.error(<span class="string">'Service Worker register error: '</span>, err);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="起一个node服务模拟服务器发送消息"><a href="#起一个node服务模拟服务器发送消息" class="headerlink" title="起一个node服务模拟服务器发送消息"></a><strong>起一个node服务模拟服务器发送消息</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpush = <span class="built_in">require</span>(<span class="string">'web-push'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vapidKeys = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  publicKey: <span class="string">'BMz9tUR-Iq3W2K0u1fy0qb5p1zD65s7N0laipwmuq7yefjASIkbrFUXKjmEmayOClvCdc0ytiLSblU1UGTnSmkY'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  privateKey: <span class="string">'WQlcnnMc6ehYztTTUcn12EI4sCPVtA8EG18yXDgZn5I'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">webpush.setVapidDetails(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="string">'https://star.toutiao.com'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  vapidKeys.publicKey,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  vapidKeys.privateKey</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> url = req.url.split(<span class="string">'?'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> query = querystring.parse(url[<span class="number">1</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (url[<span class="number">0</span>] === <span class="string">'/subscription'</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> subscription = <span class="built_in">JSON</span>.parse(query.subscription) || &#123;&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> pushMessage(subscription), <span class="number">5000</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    res.end(<span class="string">'success'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushMessage</span>(<span class="params">subscription</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//发送了个“heiheihei”给客户端</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">  webpush.sendNotification(subscription, <span class="string">'heiheihei'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'push service的相应数据:'</span>, <span class="built_in">JSON</span>.stringify(data));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 判断状态码，440和410表示失效</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (err.statusCode === <span class="number">410</span> || err.statusCode === <span class="number">404</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">return</span> util.remove(subscription);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">      <span class="built_in">console</span>.log(subscription);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">      <span class="built_in">console</span>.log(err);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">server.listen(<span class="string">'9876'</span>, () =&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'listen 9876'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><h4 id="service-worker中监听服务器主动发送的消息"><a href="#service-worker中监听服务器主动发送的消息" class="headerlink" title="service worker中监听服务器主动发送的消息"></a><strong>service worker中监听服务器主动发送的消息</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端主动推送</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'push'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[Service Worker] Push Received.'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">`[Service Worker] Push had this data: "<span class="subst">$&#123;event.data.text()&#125;</span>"`</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> title = <span class="string">'有新的任务啦'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> options = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    body: event.data.text(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    icon: <span class="string">'url'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    badge: <span class="string">'url'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> notificationPromise = self.registration.showNotification(title, options);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  event.waitUntil(notificationPromise);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'notificationclick'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[Service Worker] Notification click Received.'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">  event.notification.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  event.waitUntil(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    clients.openWindow(<span class="string">'/mobile/sup/task-center'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>First-of-type</title>
      <link href="/2019/11/11/2019/First-of-type/"/>
      <url>/2019/11/11/2019/First-of-type/</url>
      
        <content type="html"><![CDATA[<p>今天在写一个css样式时，试图用first-of-type来修改第一个拥有特殊class标签的样式，发现并未生效，后来发现一直以来自己对first-of-type，last-of-type，nth-of-type这类标签的运用场景理解错了。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当时的html代码结构是这样的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span>一行元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span>一行元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span>一行元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre></td></tr></table></figure><p>其中每个 <code>一行元素</code> 中间相隔10px，而 <code>标题</code> 与 <code>行内元素</code> 相隔大一些：15px，当时的想法是对第一个class是row的 <code>一行元素</code> 做特殊的样式处理，css代码为：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card</span> <span class="selector-class">.row</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  &amp;:first-of-type&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="attribute">margin-top</span>: <span class="number">14px</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>伪类没有生效</p><h2 id="MDN解释："><a href="#MDN解释：" class="headerlink" title="MDN解释："></a>MDN解释：</h2><p>贴上了中英文解释</p><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">CSS</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes" target="_blank" rel="noopener">伪类</a> <strong>:first-of-type</strong> 表示一组兄弟元素中其类型的第一个元素。</p></blockquote><blockquote><p>The :first-of-type <a href="https://developer.mozilla.org/en-US/docs/Web/CSS" target="_blank" rel="noopener">CSS</a> <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes" target="_blank" rel="noopener">pseudo-class</a> represents the first element of its type among a group of sibling elements.</p></blockquote><p>这里乍一眼看容易产生误解，first-of-type作用于满足筛选条件的第一个元素，实际上这个伪类首先作用与element上，前面只是基于选中的element的再次筛选。</p><p>也就是说，上面的html结构能被first-of-type选中的element只有 <code>&lt;div class=&quot;title&quot;&gt;标题&lt;/div&gt;</code> ，而我又对可以被选中元素加上class=”row”的条件筛选，最后的结果就是没有符合的元素了。</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"a"</span>&gt;</span>a1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"a"</span>&gt;</span>a2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"a"</span>&gt;</span>a3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"b"</span>&gt;</span>b4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"b"</span>&gt;</span>b5<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"c"</span>&gt;</span>c6<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">//不加筛选条件 a1和b4会变红 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">//他两分别是p元素和div元素在father下的第一个子元素</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> <span class="selector-pseudo">:first-of-type</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="attribute">color</span>:red</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">//加上筛选条件.a  a1会变红</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">//上一个例子里挑选出来的元素中符合class=a的只有a1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> <span class="selector-class">.a</span><span class="selector-pseudo">:first-of-type</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  <span class="attribute">color</span>:red</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">//加上筛选条件.b b4会变红，原因同上</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> <span class="selector-class">.b</span><span class="selector-pseudo">:first-of-type</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  <span class="attribute">color</span>:red</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">//加上筛选条件.c </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">//虽然&lt;p class="c"&gt;c6&lt;/p&gt;的class=c，但是c6已经不是father下第一个p元素了，因此没有符合这个条件的元素</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> <span class="selector-class">.c</span><span class="selector-pseudo">:first-of-type</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">  <span class="attribute">color</span>:red</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="问题的解决方案"><a href="#问题的解决方案" class="headerlink" title="问题的解决方案"></a>问题的解决方案</h2><p>将html结构修改成如下就好：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span>一行元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span>一行元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span>一行元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>first-of-type / last-of-type / nth-of-type / nth-last-of-type ….等伪类都是首先筛选符合条件的element元素，再根据自定义的筛选条件过滤一遍已经筛选过一次的element元素。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue数据双向绑定的源码解析</title>
      <link href="/2019/10/30/2019/vue%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/10/30/2019/vue%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>关于vue是观察者模式还是发布订阅模式网上一直众说纷纭。<br>我之前一直认为vue是发布订阅模式，dep对象作为发布订阅模式里的event channel来处理数据更新和通知，后来听了字节跳动银国徽老师的《Mvvm设计模式》课程，阅读完vue的源码后，对vue是如何实现双向绑定有个更清楚的认识。</p><h2 id="观察者模式和发布订阅模式"><a href="#观察者模式和发布订阅模式" class="headerlink" title="观察者模式和发布订阅模式"></a>观察者模式和发布订阅模式</h2><p>首先简单介绍一下观察者模式和发布订阅模式的概念和他们的区别：</p><p><img src="https://user-images.githubusercontent.com/18004081/67863951-d07f9d80-fb5f-11e9-9e9b-40e35716cc6d.png" alt="image"></p><p><strong>观察者模式</strong></p><blockquote><p>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。</p></blockquote><p>以卖房子为例：一个房东想卖掉自己的房子，于是他发布了一个售卖价格，有好几个买家心仪这套房子，但是又觉得价格有点小贵而犹豫不决，于是他们都关注着这套房子的房价伺机行动。</p><p>在这个例子里。房东就是那个观察目标，买家就是观察者，一个房东可能和多个买家对接，一旦房价发生变化就会告诉他们，而几个买家之间是没有相互联系的。</p><p><strong>发布订阅模式</strong></p><blockquote><p>发布订阅模式是观察者模式的实现，更利于系统的解耦和重用</p></blockquote><p>发布订阅模式和观察者模式最大的不同就是存在一个“中介”来统一处理一些事件，使得订阅者（观察者）和发布者（观察目标）没有直接联系。</p><p>还是以上面的卖房子为例：房东想卖掉自己的房子，但是又觉得自己每次更改房价就要挨个打电话通知买家自己的价格变化了实在太麻烦，于是他找了一个中介贝壳，把自己的房子信息托管给他们，以后每次更改房价他就只和中介贝壳的工作人员说一声就好了，再由贝壳的工作人员来通知那些想买房子的人。</p><p>至此，房东不再和买家直接打交道，房东甚至不知道有哪些买家关注着自己的房子信息，房东也不关心贝壳的工作人员是如何通知买家的，可能是群发消息，避免了房东挨个打电话通知的重复劳动性。</p><h2 id="为什么说vue是观察者模式"><a href="#为什么说vue是观察者模式" class="headerlink" title="为什么说vue是观察者模式"></a>为什么说vue是观察者模式</h2><p>对vue有一定了解的朋友应该都知道，vue实现双向绑定有几个重要的对象：Observer，Watcher，Dep。</p><p><img src="https://user-images.githubusercontent.com/18004081/67863963-d9706f00-fb5f-11e9-9b34-a1311eff0439.png" alt="image"></p><p>乍一眼看这张图，觉得这妥妥的是上面说的发布订阅者模式呀，Observer是观察目标，Watcher是观察者，Dep是中间那个中介Event Channel。</p><p>实际上阅读完源码后，你会发现Dep没有做任何事情，他只是一个简单的Watcher的数组集合，在每次Observer数据发生更新时，循环遍历数组集合来挨个触发每个Watcher的update方法。</p><p>下面就通过解析源码来详细说一下这个实现过程吧！</p><h2 id="vue源码实现双向绑定"><a href="#vue源码实现双向绑定" class="headerlink" title="vue源码实现双向绑定"></a>vue源码实现双向绑定</h2><p>github地址：<a href="https://github.com/vuejs/vue.git" target="_blank" rel="noopener">https://github.com/vuejs/vue.git</a></p><p>我们重点阅读 <code>src/core</code> 下这几个文件的内容：</p><p><img src="https://user-images.githubusercontent.com/18004081/67864034-f147f300-fb5f-11e9-9f94-74adf0a7522c.png" alt="image"></p><p>首先看<strong>init.js</strong>下的Vue初始化方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//options就是我们每次new一个Vue对象时传进去的那个对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Vue.prototype.__init = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  vm._self = vm</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  initLifecycle(vm)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  initEvents(vm)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  initRender(vm)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  callHook(vm,<span class="string">'beforeCreate'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  initInjections(vm) <span class="comment">// resolve injections before data/props</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  initState(vm)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  initProvide(vm) <span class="comment">// resolve provide after data/props</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  callHook(vm,<span class="string">'created'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>初始化里主要完成了初始化事件、渲染、参数、注入等过程，并按照生命周期里的规则调用事件钩子的回调函数。我们重点关注初始化数据:<strong>state.js</strong>下的<strong>initState</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  vm._watchers = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> opts = vm.$options</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    initData(vm)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    initWatch(vm, opts.watch)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这里依次检测参数中包含的 <code>props/methods/data/computed/watch</code> 并进入不同的函数进行初始化，我们只关心 <code>initData</code> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> data = vm.$options.data</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    ? getData(data, vm)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    : data || &#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!isPlainObject(data)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    data = &#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      <span class="string">'data functions should return an object:\n'</span> +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      <span class="string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">      vm</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// observe data</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>可以看到 <code>data</code> 参数支持对象和回调函数，最终返回一个对象。</p><p>接下来就是重头戏了，我们如何将data参数设置为响应式的，下面阅读最后调用的<strong>observe</strong>函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Attempt to create an observer instance for a value,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * returns the new observer if successfully observed,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * or the existing observer if the value already has one.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value ,asRootData</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> ob</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    ob = value.__ob__</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    shouldObserve &amp;&amp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    !isServerRendering() &amp;&amp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    !value._isVue</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  ) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    ob.vmCount++</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> ob</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>源码里的注释写的比较清楚：observe函数生成一个基于value的观察目标 <code>new Observer(value)</code> ，如果存在则返回已存在的。Observer累保存在value的 <code>__ob__</code> 属性下。</p><p>下面我们来详细看一下Observer类的初始化函数（<strong>observer/index.js</strong>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Observer class that is attached to each observed</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * object. Once attached, the observer converts the target</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * object's property keys into getter/setters that</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * collect dependencies and dispatch updates.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span> (value) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">this</span>.value = value</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">this</span>.vmCount = <span class="number">0</span> <span class="comment">// number of vms that have this object as root $data</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// def函数是defineProperty的简单封装</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 在es5及更低版本的js里，无法完美继承数组，这里检测并选取合适的函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// protoAugment函数使用原型链继承，copyAugment函数使用原型链定义（即对每个数组defineProperty）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (hasProto) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">      protoAugment(value, arrayMethods)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">      copyAugment(value, arrayMethods, arrayKeys)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.observeArray(value)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.walk(value)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>如注释所说：它会被关联到每一个被检测的对象，使用 <code>getter/setter</code> 修改其默认读写，用于收集依赖和发布更新。至此，我们能想到Vue是如何进行双向数据绑定的，改写data的访问器属性：get/set，在get的时候添加观察者，在set的时候告知观察者。</p><p>在这一步，我们给观察目标Observer挂上一个dep属性，属性值是一个Dep对象，我们来看一下Dep的数据结构（Dep下的源码后面再详细展开）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dep对象的结构</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">id: 每个观察目标的唯一标识。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">subs: 观察者列表。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">target: 全局唯一的观察者对象，因为只能同时计算和更新一个观察者的值。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">addSub(): 使用<span class="string">`push()`</span>方法添加一个观察者。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">removeSub(): 使用<span class="string">`splice()`</span>方法移除一个观察者。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">depend(): 将自己添加到当前观察者对象的依赖列表。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">notify(): 在数据被更新时，会遍历subs对象，触发每一个观察者的更新。</span></pre></td></tr></table></figure><p>这里可以看出Vue对于数组类型的value和非数组类型的value分别做了两种处理，是因为我们观察的只能是一个对象，而不能是一个数组，数字或者字符串。对于数组的处理这里不做详细展开了，有兴趣的同学可以自行阅读源码</p><p>对于非数组的value，调用了walk方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">  * Walk through all properties and convert them into</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">  * getter/setters. This method should only be called when</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">  * value type is Object.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">  */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"> walk (obj) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">     defineReactive(obj, keys[i])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr></table></figure><p>注释：遍历obj下的属性并将其转换成使用 <code>getter/setter</code> 修改其默认读写的属性。所以 <code>defineReactive</code> 就是那个关键的函数了！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Define a reactive property on an Object.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj,key,val,customSetter,shallow</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    val = obj[key]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    enumerable: <span class="literal">true</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    configurable: <span class="literal">true</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        dep.depend()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">          childOb.dep.depend()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            dependArray(value)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">return</span> value</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">        customSetter()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// #7981: for accessor properties without setter</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (setter) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        setter.call(obj, newVal)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">        val = newVal</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">      dep.notify()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>终于看到了关键的重头戏！Vue在这里重写了属性的访问器属性get/set。</p><p>对于get访问器属性，在执行完属性原本的getter函数后，执行了<strong>dep.dependd()</strong>方法</p><p>关于条件判断里的<strong>Dep</strong>，代码里是这么定义的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// The current target watcher being evaluated.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is globally unique because only one watcher</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// can be evaluated at a time.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Dep.target = <span class="literal">null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetStack = []</span></pre></td></tr></table></figure><p>注释看的出来：<strong>Dep.targe</strong>t是全局唯一的<strong>watcher</strong>对象，也就是当前正在指令计算的观察者，它会在计算时赋值成一个watcher对象，计算完成后赋值为null。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  depend () &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      Dep.target.addDep(<span class="keyword">this</span>) /</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"> <span class="comment">//...    </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>depend的函数只是调用了<strong>Dep.target.addDep()</strong>，那我们看一下Watch类下的addDep函数的定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watch</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">   * Add a dependency to this directive.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">   */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  addDep (dep) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> id = dep.id</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">this</span>.newDepIds.add(id)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">this</span>.newDeps.push(dep)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        dep.addSub(<span class="keyword">this</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这里根据dep的id简单的做了一次去重操作，确定没有重复依赖后执行了<strong>dep.addSub(this)</strong>，于是我们再回到dep class下阅读关于addSub的定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   <span class="comment">//为这个观察对象下的dep属性添加</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//仅仅只是把Wacher压入subs堆栈里，并没有做其他任何操作</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  addSub (Watcher) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.subs.push(Watcher)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  &#125;，</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>看到了没有！这里没有做任何的操作，只是把这个Watcher对象放到了这个Observer.dep.subs数组里！</p><p>那我们再看看setter函数下执行的<strong>dep.notify</strong>函数的定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  notify () &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !config.async) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// subs aren't sorted in scheduler if not running async</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// order</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      subs[i].update()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>看到了没有！这里也没有对Watcher做任何的操作，只是依次执行subs队列里Watcher对象下的update方法。Dep其实只是一个Wacher对象的集合，方便每次Observe更新时通知所有的Wacher —- 调用他们的update方法，本身并没有做任何的封装处理：Observer和Wacher依旧是强耦合状态。</p><p>至此，看完源码后同学们能理解为什么说Vue的数据绑定是观察者模式了吧。</p><p>关于Vue里Dep的定位，接着观察者模式里提到的卖房子的例子：他有点像房东收集所有买家电话号码的电话薄，房东在通知买家房价发生变化时可以通过查阅本子更快更方便的通知到所有买家，但本质上还是房东直接和买家发生交集的。</p><h2 id="为什么vue要用观察者模式"><a href="#为什么vue要用观察者模式" class="headerlink" title="为什么vue要用观察者模式"></a>为什么vue要用观察者模式</h2><p>课堂上有个同学提到了一个很有意思的说法，解释vue为什么要用观察者模式。</p><p>发布订阅模式其中一个特点是订阅通知的处理逻辑都交给了Event Channel来处理，这要带来的好处是发布者和订阅者关系解耦，代价就是引入了Event Channel会使代码逻辑更加复杂。</p><p>比如一个典型的发布订阅模型就是我们的dom事件，一个dom可能有多种类型的事件：click事件，mousedown事件…，不同的dom可能有相同类型的事件：两个button按钮都用了click事件。那么对于dom来说我究竟该出发哪一种类型的什么事件dom本身是不关心的，这个触发机制是浏览器来完成的，浏览器就充当了我们说的Event Channel角色。</p><p>而对于Vue这种数据双向绑定的应用场景，他不像dom那样有click/mousedown各种各样的事件类型，他仅仅只有一个更新的订阅通知，即，他只需要告诉他的观察者他更新了，而不用告诉观察者我是A类型的更新还是B类型的更新。</p><p>在这种情况下，直接的告知可能是最方便的做法，引入Event Channel反而会增加代码的复杂度。所以有的时候，没有哪种模式更好哪种模式更高级的说法，还是要根据具体的应用场景来做选择。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>发布订阅模式是观察者模式的一种实现，他两区别的关键在于是否有个充当“中介”的Event Channel。</li><li>Vue的dep对象只是一个Watcher的集合，本身没有做任何操作，所以Vue的双向数据绑定属于观察者模式。</li><li>观察者模式和发布订阅模式没有谁更优的说法，应该根据具体的应用场景采取更合适的方法。</li></ul><p>以上就是我对vue的初步了解，有什么问题或不准确的地方欢迎各方大佬们留言指正~</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新电脑软件配置</title>
      <link href="/2019/10/11/2019/%E6%96%B0%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/10/11/2019/%E6%96%B0%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>避免换台电脑像搬家一样累</p><ul><li><p>node  :<a href="https://www.jianshu.com/p/c641dcc47b48" target="_blank" rel="noopener">利用n管理node版本</a></p></li><li><ul><li>git and ssh</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># 一路回车，不要设置密码</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &lt;邮箱&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">$ cat ~<span class="regexp">/.ssh/i</span>d_rsa.pub</span></pre></td></tr></table></figure></li></ul><ul><li><p>Webpack</p></li><li><p>ITerm2：<a href="https://www.jianshu.com/p/405956cdaca6" target="_blank" rel="noopener">ITerm2，让你的mac控制台更加丰富高效</a></p></li><li><p>VSCode：<a href="https://juejin.im/entry/587e0f2f570c352201113e14" target="_blank" rel="noopener">教你打造一款颜值逆天的 VS Code</a></p></li><li><p><a href="https://juejin.im/post/5c73dcd05188256fd62d4d27" target="_blank" rel="noopener">VS Code 配置与插件推荐 2019 年版</a><br>跳转到定义部分  Definition Resolve  and  vue-definition / react</p></li><li><p>Typora <a href="https://mac.softpedia.com/get/Word-Processing/?utm_source=spd&utm_campaign=postdl_redir" target="_blank" rel="noopener">download</a></p></li><li><p>Charles </p></li></ul><p><strong>chrome</strong></p><ul><li><a href="mailto:t.ding.603@gmail.com" target="_blank" rel="noopener">t.ding.603@gmail.com</a>  收藏夹插件导入</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Intersection observer</title>
      <link href="/2019/09/26/2019/IntersectionObserver%E5%AE%9E%E7%8E%B0%E6%BB%9A%E5%8A%A8%E4%BA%A4%E4%BA%92/"/>
      <url>/2019/09/26/2019/IntersectionObserver%E5%AE%9E%E7%8E%B0%E6%BB%9A%E5%8A%A8%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<p>拥有“交叉观察者“小宝贝，从此妈妈再也不用担心我的滚动交互了。</p><h2 id="通过js计算属性来实现"><a href="#通过js计算属性来实现" class="headerlink" title="通过js计算属性来实现"></a>通过js计算属性来实现</h2><p>记得以前写懒加载时，用的是一个（名字不重要）的第三方库，基本思想是：通过在onScroll事件里计算图片的offsetTop和clientHeight来判断图片是否到达了可展示区域，再替换img的src来加载正确的图片地址。</p><p>其实大部分和滚动相关交互的实现思路都和上述懒加载的实现差不多：<strong>通过在onScroll里对一些计算属性值的判断来做一些操作</strong>。这种方法不好的地方是代码里充斥着大量的offsetTop，clientHeight等取值计算，一来看着不舒服，二来这种计算属性的计算会造成浏览器的重绘，对性能上有一定的影响。</p><h2 id="Intersection-observer小利器"><a href="#Intersection-observer小利器" class="headerlink" title="Intersection observer小利器"></a>Intersection observer小利器</h2><p>Intersection observer ：交叉观察者，顾名思义，他是一个判断两个元素是否发生交叉的观察者！ </p><p>这里是详细<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API" target="_blank" rel="noopener">MDN</a>介绍：Intersection Observer API 允许你配置一个回调函数，每当目标(<strong>target</strong>)元素与设备视窗或者其他指定元素发生交集的时候执行。设备视窗或者其他元素我们称它为根元素或根(<strong>root</strong>)。通常，您需要关注文档最接近的可滚动祖先元素的交集更改，如果元素不是可滚动元素的后代，则默认为设备视窗。如果要观察相对于根(<strong>root</strong>)元素的交集，请指定根(<strong>root</strong>)元素为 <code>null</code> 。</p><p><img src="https://user-images.githubusercontent.com/18004081/65669455-2d29fd00-e076-11e9-88b3-dbba44aee474.png" alt="image"></p><p>请先忍忍，例子里有动图介绍！</p><h2 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(callback, options)</span></pre></td></tr></table></figure><h3 id="2-options"><a href="#2-options" class="headerlink" title="2.options"></a>2.options</h3><p>传递到 <code>IntersectionObserver()</code> 构造函数的 <code>options</code> 对象，允许你控制调用观察者的回调环境，具体配置有：</p><ul><li><p><strong>root</strong></p><p>接受一个dom，作为发生交叉的视图窗口，必须是目标元素的父级元素。如果未指定或者为null，则默认为浏览器的视窗。</p></li><li><p><strong>rootMargin</strong></p><p>root元素的外边距，可以扩大/缩小视窗的交集范围。用法和css中的margin属性一样，比如： <code>“10px 120px 30px -60px”(top, right, bottom, left)</code> ，正数时是往外扩张，负数时是往里缩放。</p></li><li><p><strong>threshold</strong></p><p>接受一个number或者一个number数组（number的值在0 - 1中间）。当目标元素和root元素相交程度的百分比达到指定值时，构造函数里注册的回调函数将会被执行。比如设置threshold：0.5，那么当目标元素在root中的可视区域占自身50%时，触发回调函数，如果你想可见程度每增加/减少25%时就触发一次回调，那么应该设置成：threshold：[0, 0.25, 0.5, 0.75, 1]。默认是0。</p></li></ul><h3 id="3-目标（target）元素"><a href="#3-目标（target）元素" class="headerlink" title="3.目标（target）元素"></a>3.目标（target）元素</h3><p>构建后为每个观察者配置一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">document</span>.querySelector(<span class="string">'#target'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">observer.observe(target)</span></pre></td></tr></table></figure><h3 id="4-callback"><a href="#4-callback" class="headerlink" title="4.callback"></a>4.callback</h3><p>传递到 <code>IntersectionObserver()</code> 构造函数的回调函数，当达到IntersectionObserver指定的threshold时，触发回调。回调接受 <code>IntersectionObserverEntery</code> 对象和观察者列表。</p><blockquote><p>请留意，你注册的回调函数将会在主线程中被执行。所以该函数执行速度要尽可能的快。如果有一些耗时的操作需要执行，建议使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noopener"><code>Window.requestIdleCallback()</code></a> 方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">entries, observer</span>) </span>&#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Each entry describes an intersection change for one observed</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// target element</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//   entry.boundingClientRect 空间信息</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//   entry.intersectionRatio  目标元素可视区域占比</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//   entry.intersectionRect</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//   entry.isIntersecting   是否正在交叉，可判断元素是否可见</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//   entry.rootBounds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//   entry.target</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//   entry.time</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="5-常用方法"><a href="#5-常用方法" class="headerlink" title="5.常用方法"></a>5.常用方法</h3><ul><li>observe(dom)：开始监听dom元素作为目标元素</li><li>unobserve(dom)：结束监听dom元素</li><li>takRecords()：返回所有监听的目标元素集合</li><li>disconnect()：停止所有监听</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="监听一个class-”box”的元素是否进入视窗"><a href="#监听一个class-”box”的元素是否进入视窗" class="headerlink" title="监听一个class=”box”的元素是否进入视窗"></a>监听一个class=”box”的元素是否进入视窗</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> box = <span class="built_in">document</span>.querySelector(<span class="string">'.box'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="params">entries</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    entries.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(item.isIntersecting? <span class="string">"进入了视窗的内部"</span>:<span class="string">"离开了视窗的内部"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">observer.observe(box)</span></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://user-images.githubusercontent.com/18004081/65669562-5e0a3200-e076-11e9-9a7f-3f5ce04ec0b0.gif" alt="QQ20190926-141057-HD"></p><h3 id="监听多个class-”box”的元素是否进入视窗"><a href="#监听多个class-”box”的元素是否进入视窗" class="headerlink" title="监听多个class=”box”的元素是否进入视窗"></a>监听多个class=”box”的元素是否进入视窗</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> box = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.box'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="params">entries</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">`此时一共有<span class="subst">$&#123;entries.length&#125;</span>个元素发生交叉行为`</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">box.forEach(<span class="function"><span class="params">item</span>=&gt;</span>observer.observe(item))</span></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/18004081/65669640-83973b80-e076-11e9-97ee-e847445da391.gif" alt="QQ20190926-144225-HD"><br><img src="https://user-images.githubusercontent.com/18004081/65669657-898d1c80-e076-11e9-94c3-3f00233e731b.gif" alt="QQ20190926-144457-HD"></p><p>为什么下面打印出来的length是1呢？entries返回的是<strong>当前正在发生交叉</strong>的目标集合。上面是大家一起发生交叉，每次返回的集合长度都是3，下面是大家轮流发生交叉，每次返回的集合长度都是1。</p><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>相关例子的代码已上传至<a href="https://github.com/includeios/document/tree/master/demo/intersectionDemo" target="_blank" rel="noopener">intersectionDemo</a></p><h3 id="1-懒加载"><a href="#1-懒加载" class="headerlink" title="1.懒加载"></a>1.懒加载</h3><p>用Intersection observer实现懒加载代码优雅多了，你只需将图片设置为目标函数。</p><p>假设html为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 例子一：懒加载 --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"contain lazy-load-contain"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img-contain"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-origin</span>=<span class="string">"./img/pic1.jpg"</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-origin</span>=<span class="string">"./img/pic2.jpg"</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-origin</span>=<span class="string">"./img/pic3.jpg"</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-origin</span>=<span class="string">"./img/pic4.jpg"</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-origin</span>=<span class="string">"./img/pic5.jpg"</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-origin</span>=<span class="string">"./img/pic6.jpg"</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-origin</span>=<span class="string">"./img/pic7.jpg"</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>     </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre></td></tr></table></figure><p>js相关代码为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒加载</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lazyLoading = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> images = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.lazy-load-contain img'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="params">entries</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        entries.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(item.isIntersecting)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                <span class="built_in">console</span>.log(<span class="string">'开始懒加载：'</span>,item.target.dataset.origin)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                item.target.src = item.target.dataset.origin <span class="comment">//开始加载图片</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                observer.unobserve(item.target)  <span class="comment">//停止监听已经开始加载的图片</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;, &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        root:<span class="built_in">document</span>.querySelector(<span class="string">'.lazy-load-contain'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        rootMargin:<span class="string">"0px 0px 50px 0px"</span> <span class="comment">//在底部距离50px时就开始加载图片</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    images.forEach(<span class="function"><span class="params">item</span>=&gt;</span>observer.observe(item))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>效果为：<br>（啊，文件太大被吞了，可通过运行demo里的例子自己看下哈，不过我拍的照片可真好看呀。）</p><h3 id="2-列表加载数据"><a href="#2-列表加载数据" class="headerlink" title="2.列表加载数据"></a>2.列表加载数据</h3><p>移动端滚动列表加载数据常见case是：下拉到页尾时继续加载下一页数据，这个也可以用Intersection observer来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;!-- 例子二：列表滚动加载数据 --&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"contain list-scroll-load"</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"img-contain"</span> /&gt;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"footer-reference"</span>&gt;加载中...&lt;<span class="regexp">/div&gt;  </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">&lt;/</span>div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> listLoading = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> listDate = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> addDate = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        listDate = listDate.concat([<span class="string">"./img/pic1.jpg"</span>,<span class="string">"./img/pic2.jpg"</span>,<span class="string">"./img/pic3.jpg"</span>, <span class="string">"./img/pic4.jpg"</span>,<span class="string">"./img/pic5.jpg"</span>,<span class="string">"./img/pic6.jpg"</span>,<span class="string">"./img/pic7.jpg"</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> convertHtml = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">let</span> dom = <span class="string">''</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        listDate.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            dom += <span class="string">`&lt;img src="<span class="subst">$&#123;item&#125;</span>"/&gt;`</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">document</span>.querySelector(<span class="string">'.list-scroll-load .img-contain'</span>).innerHTML = dom</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="params">entries</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//如果底部标识进入交叉区，开始请求下一页数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(entries[<span class="number">0</span>].isIntersecting)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">console</span>.log(<span class="string">'开始请求数据'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            addDate()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            convertHtml()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    &#125;, &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        root:<span class="built_in">document</span>.querySelector(<span class="string">'.list-scroll-load'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        rootMargin:<span class="string">"0px 0px 100px 0px"</span> <span class="comment">//在底部距离100px的时候就开始加载数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    observer.observe(<span class="built_in">document</span>.querySelector(<span class="string">'.footer-reference'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>效果如下：<br>只是个简单的例子，每次到底部补充数据替换dom，所以替换dom时页面会有点晃动，如果你用react/vue这种牛逼哄哄的框架就不会有这种问题啦<br>（啊，文件依旧太大被吞了，可通过运行demo里的例子自己看下哈，不过我拍的照片确实好看呢。）<br>当然你可以把1和2的例子结合在一起，做一个底部请求数据同时懒加载的列表页。</p><h3 id="3-模拟position-sticky实现吸顶效果"><a href="#3-模拟position-sticky实现吸顶效果" class="headerlink" title="3.模拟position: sticky实现吸顶效果"></a>3.模拟position: sticky实现吸顶效果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">    &lt;!-- 例子四：吸顶 --&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"contain stick-top-contain"</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"title"</span>&gt;标题XXXXX&lt;<span class="regexp">/div&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">      &lt;div class="top-reference"&gt;&lt;/</span>div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"stick-bar"</span>&gt;筛选框等需要吸顶的元素&lt;<span class="regexp">/div&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">      &lt;div class="img-contain"&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">        &lt;img src="./img</span><span class="regexp">/pic1.jpg" /</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &lt;img src=<span class="string">"./img/pic2.jpg"</span> /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        &lt;img src=<span class="string">"./img/pic3.jpg"</span> /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        &lt;img src=<span class="string">"./img/pic4.jpg"</span> /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &lt;img src=<span class="string">"./img/pic5.jpg"</span> /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        &lt;img src=<span class="string">"./img/pic6.jpg"</span> /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &lt;img src=<span class="string">"./img/pic7.jpg"</span> /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">      &lt;<span class="regexp">/div&gt;  </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stickTop = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="params">entries</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(entries[<span class="number">0</span>].isIntersecting)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">document</span>.querySelector(<span class="string">'.stick-bar'</span>).classList.remove(<span class="string">'fix-top'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">document</span>.querySelector(<span class="string">'.stick-bar'</span>).classList.add(<span class="string">'fix-top'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;, &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        root:<span class="built_in">document</span>.querySelector(<span class="string">'.stick-top-contain'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    observer.observe(<span class="built_in">document</span>.querySelector(<span class="string">'.top-reference'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>效果如下：<br>（终于有个可以上传的例子了！，我拍的照片是不是很好看!）<br><img src="https://user-images.githubusercontent.com/18004081/65670779-9f9bdc80-e078-11e9-8e38-94747f2119c8.gif" alt="QQ20190926-161255-HD"></p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>IE不兼容，不过有<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fw3c%2FIntersectionObserver%2Ftree%2Fmaster%2Fpolyfill">官方的polyfill</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>更多的一些例子请移步参考：<a href="https://github.com/includeios/document/tree/master/demo/intersectionDemo" target="_blank" rel="noopener">intersectionDemo</a>，感觉还能做很多其他好玩的事情，欢迎大家补充~</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>liunx查询日志常用命令收集</title>
      <link href="/2019/09/17/2019/liunx%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%94%B6%E9%9B%86/"/>
      <url>/2019/09/17/2019/liunx%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>每次查日志很多命令都记不熟，在这里做个整理吧</p><h3 id="是否有新增记录-tail"><a href="#是否有新增记录-tail" class="headerlink" title="是否有新增记录  tail"></a>是否有新增记录  tail</h3><ul><li><strong>tail -400f demo.log</strong><br>  #demo.log后400行日志 </li></ul><h3 id="关键记录查找-grep"><a href="#关键记录查找-grep" class="headerlink" title="关键记录查找 grep"></a>关键记录查找 grep</h3><ul><li><p>*<em>grep ‘5033’ demo.log *</em><br>  #查找demo.log下所有匹配’5033’的行 </p></li><li><p><strong>grep -o ‘order-fix.curr_id:([0-9]+)‘ demo.log</strong><br>   #查找并提取（不是一行）匹配正则表达式的内容 </p></li><li><p><strong>grep -c  ‘ERROR’ demo.log</strong><br>   #输出所有包含‘ERROR’的行的数量 </p></li><li><p><strong>grep -v ‘ERROR’ demo.log</strong><br>  #输出所有不包含‘ERROR’的行 </p></li><li><p>或操作：包含123或者abc的行 </p><p> <strong>grep -E ‘123|abc’ demo.log</strong></p></li><li><p>与操作：既包含123并且包含abc的行 </p><p> <strong>grep ‘123’ demo.log | grep ‘abc’</strong></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> liunx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何优雅的进行版本回退</title>
      <link href="/2019/09/17/2019/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/"/>
      <url>/2019/09/17/2019/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/</url>
      
        <content type="html"><![CDATA[<p>平时合代码时，难免会将一些不需要的代码合到主分支里。<br>像我就经常遇到合完qa_test后，又和我说这个功能今天上不了了，希望我能把这部分功能从qa_test里踢出去。以前我的做法都是找到那条合代码的commit记录，checkout到之前版本，在新起个分支作为这次上线的qa_test，就怕莫名其妙的删除和回滚导致后面代码合不上去…。<br>后来弄懂了git reset 和 git revert，才知道自己的做法是多么的傻逼。</p><h2 id="回滚的常用两个命令"><a href="#回滚的常用两个命令" class="headerlink" title="回滚的常用两个命令"></a>回滚的常用两个命令</h2><p><strong>git reset</strong><br><strong>git revert</strong><br>这两个命令具体有什么区别呢？怎么用他们做回滚呢？</p><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86" target="_blank" rel="noopener">git reset</a></h2><p>假设我们系统里有下面这些提交记录：<br><img src="https://user-images.githubusercontent.com/18004081/65031854-9cb43400-d974-11e9-95aa-2c4d2ff4b886.png" alt="image"></p><p>A版本和B版本是我们正常的提交，C版本和D版本是错误提交，现在我们希望回退到B版本。</p><p>此时，HEAD指针指向D(5lk4er)，我们只要将HEAD指针指向B(a0fvf8)，就OK了，于是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">git reset --hard a0fvf8</span></pre></td></tr></table></figure><p>运行完命令后，本地HEAD指针如期望指向了B，如下图：<br><img src="https://user-images.githubusercontent.com/18004081/65110872-6de99c80-da0c-11e9-894a-664662741020.png" alt="image"></p><p>然而此时，远程仓库的HEAD指针依旧指向D，这个时候是提交不上去的。所以我们只能强制提交，覆盖掉远程分支的记录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">git push -f</span></pre></td></tr></table></figure><p>采用这种方法回滚的弊端显而易见：他会强制HEAD指针往回移动，丢弃后面版本的代码，如果后来发现C和D是多么绝妙的想法，他们也丢失在历史的长河了。</p><h2 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a><a href="https://git-scm.com/docs/git-revert" target="_blank" rel="noopener">git revert</a></h2><p>revert不一样的是他会反向新创建一个版本，这个版本的内容与我们需要回滚的版本内容一样，HEAD会指向这个新的版本，而不是回退到之前版本。</p><p>还是上面那个例子，想要回滚到版本B，我们先需要回滚一下D，再回滚一下C（根据提交的顺序反向回滚）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">git revert 5lk4er</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">git revert 76sdeb</span></pre></td></tr></table></figure><p>这个时候我们会新生成两个对应的分支D’和C’，HEAD指向我们最后生成的C’版本，其中的代码和B版本一模一样。如下图：<br><img src="https://user-images.githubusercontent.com/18004081/65031792-7bebde80-d974-11e9-9c7f-6e1070cca3ca.png" alt="image"></p><p>这里是需要回退两个版本，那如果有好多个版本有没有什么简便的快捷写法呢：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//git revert 最后一个要回滚的版本号^..第一个要回滚的版本号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">git revert OLDER_COMMIT^..NEWER_COMMIT</span></pre></td></tr></table></figure><p>这种回滚，错误C和D依旧有迹可循，也可以在历史的长河里再次拾起这两枚遗珠。而且，这里HEAD是往后移的，push到远程分支直接push就好。</p><h2 id="玩个高级点的"><a href="#玩个高级点的" class="headerlink" title="玩个高级点的"></a>玩个高级点的</h2><p>上面那个例子还是比较简单的，现实场景中我们经常遇到下面这种情况：错误提交的版本刚好在中间，希望既保留A又保留C，只把B踢了：<br><img src="https://user-images.githubusercontent.com/18004081/65031920-bce3f300-d974-11e9-8bc8-60accafdb4a0.png" alt="image"></p><p>直接revert到A肯定是不够的，我们还需要保留C的代码，常见做法是先回退C，回退B，再通过<a href="https://juejin.im/post/5925a2d9a22b9d0058b0fd9b" target="_blank" rel="noopener">cherry-pic</a>命令添加C版本的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">git revert 76sdeb^..a0fvf8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">git cherry pic 76sdeb</span></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/18004081/65031951-cd946900-d974-11e9-801f-d57ca4635b0b.png" alt="image"></p><p>最后，感谢这篇文章让我重获新生：<a href="https://www.itcodemonkey.com/article/13010.html" target="_blank" rel="noopener">https://www.itcodemonkey.com/article/13010.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的渲染过程2.0 — Composite</title>
      <link href="/2019/08/22/2019/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B2.0/"/>
      <url>/2019/08/22/2019/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B2.0/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章： <a href="/2019/01/03/浏览器的渲染过程/">《浏览器的渲染机制》</a>里，大概介绍了浏览器从下载完第一份document文件，到渲染出整个页面所发生的事情（也称作： <code>关键路径渲染</code> ），其中包括：1、构建对象模型（DOM，CSSOM），2、构建渲染树（RenderTree），3、布局，4、渲染。</p><p>这一篇文章我们将参考chrome浏览器的内核WebKit， 详细介绍下浏览器呈现引擎的一些概念和渲染中的一个关键环节：<strong>Composite（渲染层合并）</strong>，它所做的事情和带来的效果。</p><h2 id="浏览器的主要结构"><a href="#浏览器的主要结构" class="headerlink" title="浏览器的主要结构"></a>浏览器的主要结构</h2><p>市面上主流的几款浏览器，基本上都是由下面几个结构组成：</p><p><img src="https://user-images.githubusercontent.com/18004081/63517163-05002900-c521-11e9-9a77-650928e74fa9.png" alt="浏览器的主要结构"></p><ol><li><strong>用户界面</strong> - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li><li><strong>浏览器引擎</strong> - 在用户界面和呈现引擎之间传送指令。</li><li><strong>呈现引擎</strong> - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li><li><strong>网络</strong> - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li><li><strong>用户界面后端</strong> - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li><li><strong>JavaScript 解释器</strong>。用于解析和执行 JavaScript 代码。</li><li><strong>数据存储</strong>。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</li></ol><p>其中值得注意的是，与其他浏览器不同的是：chrome浏览器中每个tab页对应一个呈现引擎实例，每个tab页都是一个单独的进程。</p><h2 id="呈现引擎"><a href="#呈现引擎" class="headerlink" title="呈现引擎"></a>呈现引擎</h2><p>webkit的呈现引擎，官方提供的一张主流程图是：<br><img src="https://user-images.githubusercontent.com/18004081/63517233-2eb95000-c521-11e9-94d9-d8e3e42eed24.png" alt="webkit主流程"></p><p>其中有些名词和 <a href="/2019/01/03/浏览器的渲染过程/">《浏览器的渲染机制》</a>里提到的不一样，比如：Style Rules，这是webkit自己引入的几个概念，这里先解释一下，方便大家理解：</p><ul><li><p><strong>DOM Tree</strong>：浏览器将HTML解析成树形的数据结构。</p></li><li><p><strong>Style Rules</strong>：浏览器将CSS解析成树形的数据结构，对应我们的CSSOM。</p></li><li><p><strong>Render Tree</strong>：DOM和CSSOM合并后生成Render Tree。</p></li><li><p><strong>layout</strong>： 布局。有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从              属关系，从而去计算出每个节点在屏幕中的位置。</p></li><li><p><strong>painting</strong>： 渲染。按照算出来的规则，通过显卡，把内容画到屏幕上。</p></li><li><p><strong>reflow（回流/重排）</strong>：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，这个回退的过程叫 reflow。</p><blockquote><p>Dirty 位系统:<br>为了避免所有细小的更改都要从根节点进行整体布局，浏览器采用了一种“dirty 位”系统。如果某个RenderTree上的Node发生了更改，便将自身标注为“dirty”，表示需要进行布局。</p><p>有两种标记：“dirty”和“children are dirty”。“children are dirty”表示尽管呈现器自身没有变化，但它至少有一个子代需要布局</p><p>reflow时，浏览器会对Render Tree进行遍历，而仅仅只对标注了“dirty “的Node进行布局。 </p></blockquote></li><li><p><strong>repaint（重绘）</strong>：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。</p></li></ul><p>上面的过程可以合并成：</p><p><img src="https://user-images.githubusercontent.com/18004081/63517276-4395e380-c521-11e9-934e-458fe87bbfa4.png" alt="image"></p><p>实际场景下，渲染流程可以分为下面三种，layout和point这个过程是可以避免的：</p><ul><li>正常情况：JS/CSS -&gt; 计算样式 -&gt; 布局 -&gt; 绘制 -&gt; 渲染层合并</li></ul><p><img src="https://user-images.githubusercontent.com/18004081/63517276-4395e380-c521-11e9-934e-458fe87bbfa4.png" alt="image"></p><ul><li>不需要重新布局（仅触发重绘）：JS/CSS -&gt; 布局 -&gt; 绘制 -&gt; 渲染层合并</li></ul><p><img src="https://user-images.githubusercontent.com/18004081/63517342-67592980-c521-11e9-9aa0-5e001e9a2b87.png" alt="image"></p><ul><li>既不需要重新布局，也不需要重新绘制（不触发回流）：JS/CSS -&gt; 布局 -&gt; 渲染层合并</li></ul><p><img src="https://user-images.githubusercontent.com/18004081/63517370-7344eb80-c521-11e9-812e-556e3e3ca255.png" alt="image"></p><p>显而易见，第三种渲染流程浏览器的处理是最快的，那什么情况下的渲染是第三种情况呢，这里就不得不提到<strong>Compsite</strong>了</p><h2 id="Compsite"><a href="#Compsite" class="headerlink" title="Compsite"></a>Compsite</h2><p><a href="/2019/01/03/浏览器的渲染过程/">上一篇</a>我们提到，浏览器渲染时，对渲染树有着一个RenderObject -&gt; RenderLayout的转换过程：</p><p><img src="https://user-images.githubusercontent.com/18004081/50632777-f8c05f00-0f83-11e9-9f76-7c91bbb480fa.png" alt="1"></p><p>实际上，Chrome拥有两套不同的渲染路径：硬件加速路径和旧软件路径。</p><p>硬件加速路径会将一些图层的合成交给GPU处理，比CPU处理更快，而我们的RenderLayout（有些地方又称作PaintLayers）并不能作为GPU的输入，这里会将RenderLayout再转换成GraphicsLayers：<br><img src="https://user-images.githubusercontent.com/18004081/63517396-80fa7100-c521-11e9-8fa0-1788371f3c24.png" alt="image"></p><blockquote><p>某些特殊的RenderLayout会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个。</p><p>而每个GraphicsLayer（合成层单独拥有的图层） 都有一个 GraphicsContext，GraphicsContext 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后显示到屏幕上。</p></blockquote><p>很绕口对不对=  =，人性话来说，与RenderObject转换成RenderLayer一样，浏览器也是根据“某些规则”，选中一些特殊的RenderLayout节点（天选之子），这些节点将被称为Compositing Layers，Compositing Layers与其他的普通节点不一样的是他们拥有自己的GraphicsLayer，而那些没有被选中的节点，会和父层公用一个GraphicsLayer。</p><p>每个GraphicsLayer都拥有GraphicsContext，GraphicsContext输出的位图会作为纹理上传到GPU中。</p><p>什么是纹理？可以把它想象成一个从主存储器(例如 RAM)移动到图像存储器(例如 GPU 中的 VRAM)的位图图像(bitmapimage)</p><p>Chrome 使用纹理来从 GPU上获得大块的页面内容。通过将纹理应用到一个非常简单的矩形网格就能很容易匹配不同的位置(position)和变形(transformation)。这也就是3DCSS 的工作原理，它对于快速滚动也十分有效。</p><h2 id="RenderLayer-gt-GraphicsLayer，合成层的创建标准"><a href="#RenderLayer-gt-GraphicsLayer，合成层的创建标准" class="headerlink" title="RenderLayer -&gt; GraphicsLayer，合成层的创建标准"></a>RenderLayer -&gt; GraphicsLayer，合成层的创建标准</h2><p>什么情况下能使元素获得自己的层？虽然 Chrome的启发式方法(heuristic)随着时间在不断发展进步，但是从目前来说，满足以下任意情况便会创建层：</p><ul><li>直接原因（direct reason）<ul><li>硬件加速的 iframe 元素（比如 iframe 嵌入的页面中有合成层）</li><li>video 元素</li><li>覆盖在 video 元素上的视频控制栏</li><li>3D 或者 硬件加速的 2D Canvas 元素</li><li>硬件加速的插件，比如 flash 等等</li><li>在 DPI 较高的屏幕上，fix 定位的元素会自动地被提升到合成层中。但在 DPI 较低的设备上却并非如此，因为这个渲染层的提升会使得字体渲染方式由子像素变为灰阶</li><li>有 3D transform</li><li>backface-visibility 为 hidden</li><li>对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition（需要是 active 的 animation 或者 transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效）</li><li>will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等）</li></ul></li><li>后代元素原因<ul><li>有合成层后代同时本身有 transform、opactiy（小于 1）、mask、fliter、reflection 属性 </li><li>有合成层后代同时本身 overflow 不为 visible（如果本身是因为明确的定位因素产生的 SelfPaintingLayer，则需要 z-index 不为 auto）</li><li>有合成层后代同时本身 fixed 定位 </li><li>有 3D transfrom 的合成层后代同时本身有 preserves-3d 属性 </li><li>有 3D transfrom 的合成层后代同时本身有 perspective</li></ul></li><li>overlap 重叠原因，元素有一个z-index较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染）</li></ul><h2 id="合成层的性能优化"><a href="#合成层的性能优化" class="headerlink" title="合成层的性能优化"></a>合成层的性能优化</h2><p>对于提升为合成层有以下几个好处：</p><ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li><li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li><li>对于 transform 和 </li><li>\ 效果，不会触发 layout 和 paint <em>（当当当，这里就是第三种渲染模式的场景）</em></li></ul><p><strong>注意：</strong></p><ul><li>提升到合成层后合成层的位图会交GPU处理，但请注意，仅仅只是合成的处理（把绘图上下文的位图输出进行组合）需要用到GPU，生成合成层的位图处理（绘图上下文的工作）是需要CPU。</li><li>当需要repaint的时候可以只repaint本身，不影响其他层，但是paint之前还有style， layout,那就意味着即使合成层只是repaint了自己，但style和layout本身就很占用时间。</li><li>仅仅是transform和opacity不会引发layout 和paint，那么其他的属性不确定。</li></ul><p>总结来说，一般一个元素开启硬件加速后会变成合成层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。</p><p>那么针对上面这些特点，可以做的性能优化有：</p><h4 id="提升动画效果的元素"><a href="#提升动画效果的元素" class="headerlink" title="提升动画效果的元素"></a><strong>提升动画效果的元素</strong></h4><p>合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少paint，我们需要把动画效果中的元素提升为合成层。 </p><p>提升合成层的最好方式是使用 CSS 的<code>will-change</code>属性。从上一节合成层产生原因中，可以知道 will-change 设置为<code>opacity、transform、top、left、bottom、right</code> 可以将元素提升为合成层。对于不支持will-change的浏览器版本，可以加上transform属性，比如：<code>transform: translateZ(0)</code></p><h4 id="使用-transform-或者-opacity-来实现动画效果"><a href="#使用-transform-或者-opacity-来实现动画效果" class="headerlink" title="使用 transform 或者 opacity 来实现动画效果"></a><strong>使用 transform 或者 opacity 来实现动画效果</strong></h4><p>上文提到transform和opaciry属性不会引发layout和paint，值得注意的是，只有元素提升到合成层后才不会引发，普通元素修改transform和opacity还是会引发的。</p><h4 id="减少绘制区域"><a href="#减少绘制区域" class="headerlink" title="减少绘制区域"></a><strong>减少绘制区域</strong></h4><p>对于不需要重新绘制的区域应尽量避免绘制。</p><p>比如一个 fix 在页面顶部的固定不变的导航header，当页面内容某个区域 repaint 时，在没有提升为合成层时，整个屏幕包括 fix 的 header 也会被重绘。而对于固定不变的区域，我们期望其并不会被重绘，因此可以通过之前的方法，将其提升为独立的合成层。</p><h2 id="如何查看合成层"><a href="#如何查看合成层" class="headerlink" title="如何查看合成层"></a>如何查看合成层</h2><p><strong>Chrome DevTools -&gt; Rendering -&gt; Layer borders</strong><br><img src="https://user-images.githubusercontent.com/18004081/63517459-9d96a900-c521-11e9-91f0-d465f7c628da.png" alt="image"></p><p>  然后页面的合成层会用黄色的边框框出来<br><img src="https://user-images.githubusercontent.com/18004081/63517483-a8e9d480-c521-11e9-8298-05884ed42471.png" alt="image"></p><p><strong>Chrome DevTools -&gt; Layers</strong></p><p>  左边会详细列出页面的所有合成层，点击时会将这个合成层在页面的具体位置显示出来。下面的Details和Profiler会显示这个合成层的详细信息（大小，加载时间等…）<br>  <img src="https://user-images.githubusercontent.com/18004081/63517573-ca4ac080-c521-11e9-92b3-3906e4c12b37.png" alt="image"></p><h2 id="合成层可能会遇到的问题"><a href="#合成层可能会遇到的问题" class="headerlink" title="合成层可能会遇到的问题"></a>合成层可能会遇到的问题</h2><p>由于合成层本身是占用内存的，当浏览器出现大量无法被压缩的合成层时（层爆炸），会导致内存紧张，GPU资源过度消耗等问题，具体可参考<a href="https://div.io/topic/1348" target="_blank" rel="noopener">CSS3硬件加速也有坑！！！</a>,这篇文章写的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://fed.taobao.org/blog/2016/04/26/performance-composite/" target="_blank" rel="noopener">https://fed.taobao.org/blog/2016/04/26/performance-composite/</a></p><p><a href="https://www.html5rocks.com/zh/tutorials/speed/layers/" target="_blank" rel="noopener">https://www.html5rocks.com/zh/tutorials/speed/layers/</a></p><p><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Global_and_Incremental" target="_blank" rel="noopener">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Global_and_Incremental</a></p><p><a href="https://segmentfault.com/a/1190000014520786" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014520786</a></p><p><a href="https://div.io/topic/1348" target="_blank" rel="noopener">https://div.io/topic/1348</a></p><p><a href="https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2019/05/12/2019/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2019/05/12/2019/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="首先来看一个小栗子："><a href="#首先来看一个小栗子：" class="headerlink" title="首先来看一个小栗子："></a>首先来看一个小栗子：</h2><h4 id="题目：1-1-1-1-1-1"><a href="#题目：1-1-1-1-1-1" class="headerlink" title="题目：1+1+1+1+1+1"></a>题目：1+1+1+1+1+1</h4><p>A：上面的等式值是多少呀<br>B：(奋笔疾书计算)…等于6</p><p>A：那在上面的等式前面再写上”1+”呢？1+1+1+1+1+1+1，现在等于多少呀<br>B：(迅速作答)等于7<br>A：这次你为什么这么快就算出来了呀？<br>B：因为这次只要在6的基础上再加1就可以了，不需要再重新计算一遍了</p><p>从上面的小栗子里能看出来动态规划的核心就是：</p><blockquote><p>记住已经解决过的子问题的解。those who cannot remember the past are condemned torepeat it</p></blockquote><h2 id="题目一：斐波拉契数列"><a href="#题目一：斐波拉契数列" class="headerlink" title="题目一：斐波拉契数列"></a>题目一：斐波拉契数列</h2><p>fibonacci(0) = 0<br>fibonacci(1) = 1<br>fibonacci(n) = fibonacc(n-1) + fibonacc（n-2）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fib = <span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/18004081/63485426-f3ddfa80-c4d5-11e9-966f-43a9e9d46221.png" alt="image"></p><ul><li>没个节点都会执行一次，fib(2)执行了5次，时间开销大</li><li>调用没个函数时需要保留上下文，空间开销也不小</li><li>把已经执行过的子节点保存起来，后面要用到的时候直接查表读出</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//自顶向下的备忘录法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Memo = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fib = <span class="function">(<span class="params">n,Memo</span>)=&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//如果备忘录里已经有了记录，直接返回</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(Memo[n]) <span class="keyword">return</span> Memo[n]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)  Memo[n] = n</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> Memo[n] = fib(n<span class="number">-1</span>,Memo) + fib(n<span class="number">-2</span>,Memo)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> Memo[n]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">fib(<span class="number">6</span>,Memo)</span></pre></td></tr></table></figure><ul><li>依旧使用了递归，计算fib(6)到最后还是要去计算出fib(1)，fib(2)，fib(3) …</li><li>为什么不先计算出fib(1)，fib(2)，fib(3)，再去算fib(6)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//自低向上法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fib(n)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> Memo_i = <span class="number">1</span> <span class="comment">//n</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> Memo_i_1 = <span class="number">1</span> <span class="comment">//1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> Memo_i_2= <span class="number">0</span> <span class="comment">//0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>;i&lt;=n;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        Memo_i = Memo_i_1 + Memo_i_2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        Memo_i_2 = Memo_i_1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        Memo_i_1 = Memo_i</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> Memo_i</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="题目二：最长回文子串"><a href="#题目二：最长回文子串" class="headerlink" title="题目二：最长回文子串"></a>题目二：最长回文子串</h2><p><img src="https://user-images.githubusercontent.com/18004081/63485451-107a3280-c4d6-11e9-9d84-57fd0b53a748.png" alt="image"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">dp[i][j] = <span class="number">1</span>  <span class="comment">//s.substr(i，j)是回文串</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> longestPalindrome = <span class="function">(<span class="params">s</span>)=&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> len = s.length</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(len &lt;= <span class="number">1</span>) <span class="keyword">return</span> s</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span><span class="comment">//回文串起始位置</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> max = <span class="number">1</span>  <span class="comment">//回文串最大长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> dp = [][]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//首先计算长度为1和长度为2的子回文串</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        dp[i][i] = <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(i&lt;len - <span class="number">1</span> &amp;&amp; s[i] == s[i+<span class="number">1</span>])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            dp[i][i+<span class="number">1</span>] = <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            max = <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            start=i</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//从计算长度为3的子回文串开始,一直到计算长度为length的子回文串</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> l = <span class="number">3</span>;l&lt;=len;l++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i+l&lt;=len;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">const</span> j = i+l<span class="number">-1</span> <span class="comment">//终止字符位置</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(s[i] == s[j] &amp;&amp; dp[i+<span class="number">1</span>][j<span class="number">-1</span>] == <span class="number">1</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                dp[i][j] = <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                start = i</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                max = l</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> s.substr(start,max)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory Node内存溢出解决方案</title>
      <link href="/2019/01/14/2019/Node%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2019/01/14/2019/Node%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>redskull2: 0.0.49版本</p><h2 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h2><p>修改js代码热加载时，报下面的错误自动退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;--- Last few GCs ---&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">[43697:0x103800600]   342449 ms: Mark-sweep 1365.6 (1403.2) -&gt; 1365.4 (1402.7) MB, 344.7 &#x2F; 0.0 ms  (average mu &#x3D; 0.781, current mu &#x3D; 0.000) last resort GC in old space requested</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">[43697:0x103800600]   342774 ms: Mark-sweep 1365.4 (1402.7) -&gt; 1365.4 (1402.7) MB, 325.1 &#x2F; 0.0 ms  (average mu &#x3D; 0.644, current mu &#x3D; 0.000) last resort GC in old space requested</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&lt;--- JS stacktrace ---&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D; JS stack trace &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    0: ExitFrame [pc: 0x1303985041bd]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">Security context: 0x21a3cba1e589 &lt;JSObject&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    1: byteLength(aka byteLength) [0x21a307393d21] [buffer.js:530] [bytecode&#x3D;0x21a3093b5109 offset&#x3D;204](this&#x3D;0x21a3865022e1 &lt;undefined&gt;,string&#x3D;0x21a34030b0c9 &lt;Very long string[8949653]&gt;,encoding&#x3D;0x21a3cba2f7b9 &lt;String[4]: utf8&gt;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    2: arguments adaptor frame: 3-&gt;2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    3: fromString(aka fromString) [0x21a3073aa799] [buffer.js:341] [bytecode&#x3D;0x21a3093af471 of...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"> 1: node::Abort() [&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"> 2: node::OnFatalError(char const*, char const*) [&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"> 3: v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"> 4: v8::internal::Heap::FatalProcessOutOfMemory(char const*) [&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"> 5: v8::internal::Heap::AllocateRawWithRetry(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"> 6: v8::internal::Factory::NewRawTwoByteString(int, v8::internal::PretenureFlag) [&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"> 7: v8::internal::String::SlowFlatten(v8::internal::Handle&lt;v8::internal::ConsString&gt;, v8::internal::PretenureFlag) [&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"> 8: v8::String::Utf8Length() const [&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"> 9: node::Buffer::(anonymous namespace)::ByteLengthUtf8(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) [&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">10: v8::internal::FunctionCallbackArguments::Call(v8::internal::CallHandlerInfo*) [&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">11: v8::internal::MaybeHandle&lt;v8::internal::Object&gt; v8::internal::(anonymous namespace)::HandleApiCallHelper&lt;false&gt;(v8::internal::Isolate*, v8::internal::Handle&lt;v8::internal::HeapObject&gt;, v8::internal::Handle&lt;v8::internal::HeapObject&gt;, v8::internal::Handle&lt;v8::internal::FunctionTemplateInfo&gt;, v8::internal::Handle&lt;v8::internal::Object&gt;, v8::internal::BuiltinArguments) [&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">12: v8::internal::Builtin_Impl_HandleApiCall(v8::internal::BuiltinArguments, v8::internal::Isolate*) [&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">13: 0x1303985041bd</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">14: 0x130398513429</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">[1]    43696 abort      npm start</span></pre></td></tr></table></figure><h2 id="出现的原因"><a href="#出现的原因" class="headerlink" title="出现的原因"></a>出现的原因</h2><p>Node中通过javascript使用内存时只能使用部分内存（64位系统下约为1.4 GB，32位系统下约为0.7 GB），redskull2编译时占用的资源如果超出了限制，就会出现刚刚那个问题</p><p>查看任务管理器，发现每次redskull2热加载时内存稳步提升(<br><img src="https://user-images.githubusercontent.com/18004081/51100318-72700c80-1810-11e9-929b-abd13300e047.png" alt="image"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>升级redskull…, 新版本的依赖包不会有这个问题</li><li>常规webpack/node项目可以传递 <strong>–max-old-space-size</strong> 或 <strong>–max-new-space-size</strong>来调整内存大小的使用限制，但是rdskull2 本身没有监听这两个命令…. pass</li><li>npm插件 increase-memory-limit  试了redskull2下依旧无效</li><li>设置内存环境变量：export NODE_OPTIONS=–max_old_space_size=4096  暴力点可以放到npm start命令前面</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的垃圾回收机制</title>
      <link href="/2019/01/12/2019/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/01/12/2019/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h2><blockquote><p>是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束</p></blockquote><p>堆栈溢出与内存泄露的不同：<br>堆栈溢出的场景及其报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="params">()</span>=&gt;</span>&#123;b()&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="function"><span class="params">()</span> =&gt;</span> &#123;a()&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">a()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Error</span>: Uncaught <span class="built_in">RangeError</span>: Maximum call stack size exceeded</span></pre></td></tr></table></figure><p>内存泄漏的报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;--- Last few GCs ---&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">[43697:0x103800600]   342449 ms: Mark-sweep 1365.6 (1403.2) -&gt; 1365.4 (1402.7) MB, 344.7 &#x2F; 0.0 ms  (average mu &#x3D; 0.781, current mu &#x3D; 0.000) last resort GC in old space requested</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">[43697:0x103800600]   342774 ms: Mark-sweep 1365.4 (1402.7) -&gt; 1365.4 (1402.7) MB, 325.1 &#x2F; 0.0 ms  (average mu &#x3D; 0.644, current mu &#x3D; 0.000) last resort GC in old space requested</span></pre></td></tr></table></figure><h2 id="浏览器的回收机制原理"><a href="#浏览器的回收机制原理" class="headerlink" title="浏览器的回收机制原理"></a>浏览器的回收机制原理</h2><p>垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来回收其占用的内存，而浏览器实现标识无用变量的策略主要是下面两个方法：</p><h3 id="方法一：-标记清除"><a href="#方法一：-标记清除" class="headerlink" title="方法一： 标记清除"></a>方法一： 标记清除</h3><h4 id="第一步：标记阶段（mark）从引用根节点开始标记所有被引用的对象"><a href="#第一步：标记阶段（mark）从引用根节点开始标记所有被引用的对象" class="headerlink" title="第一步：标记阶段（mark）从引用根节点开始标记所有被引用的对象"></a>第一步：标记阶段（mark）从引用根节点开始标记所有被引用的对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markFromRoots</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> worklist = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> childNode <span class="keyword">in</span> Roots)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(childNode != <span class="literal">null</span> &amp;&amp; isNotMarked(childNode))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            setMarked(childNode)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            worklist.push(childNode)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            mark()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">         </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mark</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(!isEmpty(worklist))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">const</span> PointNode = worklist.pop()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> childNode <span class="keyword">in</span> PointNode)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(childNode != <span class="literal">null</span> &amp;&amp; isNotMarked(childNode))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                setMarked(childNode)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                worklist.push(childNode)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="第二步：清除（sweep）没有被标记的对象"><a href="#第二步：清除（sweep）没有被标记的对象" class="headerlink" title="第二步：清除（sweep）没有被标记的对象"></a>第二步：清除（sweep）没有被标记的对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">functon sweep(start,end)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    while(start &lt; end)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        const Node &#x3D; Stack[start]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        if isMarked(Node)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            setUnMarked(Node)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        else free(Node)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        start ++</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">sweep(Stack.startLocation,Stack.endLocation)</span></pre></td></tr></table></figure><p>在进行一次标记清除后，内存空间不再连续，会出现很多内存碎片，如果后续需要分配一个需要内存空间较大的对象时，如果所有的内存碎片不够用，将会使得浏览器无法完成此次分配，提前触发垃圾回收。</p><h3 id="方法一点五：-标记整理"><a href="#方法一点五：-标记整理" class="headerlink" title="方法一点五： 标记整理"></a>方法一点五： 标记整理</h3><p>标记清除的升级版.<br>清除完后将活着的对象移动到一起去。<br>IE8+,Firefox,Chrome,Opera等主流浏览器的JavaScript都是采取标记清除（整理）来进行垃圾回收的，只不过垃圾收集的时间和间隔互有不同.</p><h3 id="方法二：-引用计数"><a href="#方法二：-引用计数" class="headerlink" title="方法二： 引用计数"></a>方法二： 引用计数</h3><p>IE6,7对DOM对象进行此操作回收.<br>跟踪记录每个值被引用的次数。当一个对象（值）被赋给莫个变量时，则这个对象（值）的引用次数加1，如果这个变量的值变成另外一个（不再引用这个对象），那么这个对象的引用次数减1。当这个对象（值）的引用次数变为0时，说明这个变量没有在使用了，因此可以将其占用的空间收回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;  <span class="comment">//对象&#123;&#125;的引用次数+1 = 1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = a   <span class="comment">//对象&#123;&#125;的引用次数+1 = 2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">a = <span class="literal">null</span>    <span class="comment">//对象&#123;&#125;的引用次数-1 = 1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">b = <span class="literal">null</span>    <span class="comment">//对象&#123;&#125;的引用次数-1 = 0 可以被回收了</span></span></pre></td></tr></table></figure><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>没有办法解决循环引用的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> a = &#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> b = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    a.prop = b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    b.prop = a</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">test()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//test执行完后，a和b的引用次数都是2，不会被回收</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//标记清除不会有问题，此时test执行完后，两个对象都已经离开环境，会被标记清除</span></span></pre></td></tr></table></figure><p>可能会写出的循环引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    element.onclick= <span class="function"><span class="keyword">function</span> <span class="title">anotherFunction</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"anotherElement"</span>).innerHTML = <span class="string">"Processing..."</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//解决办法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    element = <span class="literal">null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="chrome-v8引擎（node-垃圾回收机制"><a href="#chrome-v8引擎（node-垃圾回收机制" class="headerlink" title="chrome v8引擎（node)垃圾回收机制"></a>chrome v8引擎（node)垃圾回收机制</h2><ul><li>新生代：存放的对象生命周期很短，分配的内存比较小，垃圾回收比较频繁</li><li>老年代：存放的对象生命周期比较长，分配的内存比较大，垃圾回收不是很频繁</li></ul><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>Scavenge算法和cheney算法。<br>内存一分为二，一个处于使用的状态，称为Form空间，一个处于闲置的状态，称为To空间。<br>分配对象时，先是在Form空间进行分配的。当开始进行垃圾回收算法时，会检查Form空间的存活对象，将这些存活的对象复制到To空间中，而非活跃对象占用的空间将会被释放。<br>完成复制后，Form空间和To空间的角色会发生对换。</p><h3 id="新生代-gt-老生代"><a href="#新生代-gt-老生代" class="headerlink" title="新生代 =&gt; 老生代"></a>新生代 =&gt; 老生代</h3><p>对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一个新生代的清理，如果是，则复制到老生代中，否则复制到To空间中。<br>对象从From空间复制到To空间时，如果To空间已经被使用了超过25%，那么这个对象直接被复制到老生代。</p><h3 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h3><p>标记清除和标记整理结合，主要采用标记清除算法，如果空间不足以分配从新生代晋升过来的对象时，才使用标记整理。</p><h2 id="造成内存泄露的情况"><a href="#造成内存泄露的情况" class="headerlink" title="造成内存泄露的情况"></a>造成内存泄露的情况</h2><ul><li>全局变量</li><li>DOM元素的引用（IE):手动删除</li><li>被遗忘的定时器（IE）:手动清除</li><li>闭包<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//每次replacething被调用，something都会获取一个新的对象，包含一个大数组和一个新的闭包（someMethod)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//unused也保持一个闭包（anotherthing）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//someMethod与unused共享作用域，即使它未使用，但是它对originalThing的引用强制它保持活动</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> something = <span class="literal">null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someMessage = <span class="string">'Hello'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> replacething = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> anotherthing = something</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> unused = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span>(anotherthing)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    something = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">      longStr:<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000000</span>).join(<span class="string">'*'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">      someMethod:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(someMessage)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li></ul><h2 id="Chrome查看工具"><a href="#Chrome查看工具" class="headerlink" title="Chrome查看工具"></a>Chrome查看工具</h2><p><a href="https://www.jianshu.com/p/504bde348956" target="_blank" rel="noopener">https://www.jianshu.com/p/504bde348956</a><br><a href="https://blog.csdn.net/c11073138/article/details/84700482" target="_blank" rel="noopener">https://blog.csdn.net/c11073138/article/details/84700482</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的渲染过程</title>
      <link href="/2019/01/03/2019/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/01/03/2019/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>通常，我们只需要编写HTML，CSS，JavaScript，浏览器上就能呈现出漂亮的网页了，但是浏览器是如何使用我们的代码在屏幕上渲染像素的呢？</p><h2 id="首先，请先看一张大图"><a href="#首先，请先看一张大图" class="headerlink" title="首先，请先看一张大图"></a>首先，请先看一张大图</h2><p>浏览器将HTML，CSS，JavaScript代码转换成屏幕上所能呈现的实际像素，这期间所经历的一系列步骤，叫做关键渲染路径（Critical Rendering Path）。其中包含：</p><ul><li>构建对象模型（DOM，CSSOM）</li><li>构建渲染树（RenderTree）</li><li>布局</li><li>渲染<br>在构建对象模型到构建渲染树的这一过程，还穿插着JS脚本的加载和执行。如下图所示：<br><img src="https://user-images.githubusercontent.com/18004081/58801936-850fa480-863e-11e9-9971-2a42e508121a.jpg" alt="关键路径渲染"></li></ul><h2 id="1-DOMTree的构建"><a href="#1-DOMTree的构建" class="headerlink" title="1.DOMTree的构建"></a>1.DOMTree的构建</h2><p>浏览器的渲染从解析HTML文档开始，宏观上，可以分为下面几个步骤：</p><p><img src="https://user-images.githubusercontent.com/18004081/50632501-0d502780-0f83-11e9-8d83-e27f266e5947.png" alt="构建DOM的具体步骤"></p><h3 id="第一步-解析"><a href="#第一步-解析" class="headerlink" title="第一步 解析"></a>第一步 解析</h3><p>从网络或者磁盘下读取的HTML原始字节码，通过设置的charset编码，转换成相字符<br>  <img src="https://user-images.githubusercontent.com/18004081/55075896-0a228e80-50cf-11e9-8861-1698b803edbf.jpg" alt="将字符码转成字符"></p><h3 id="第二步-token化"><a href="#第二步-token化" class="headerlink" title="第二步 token化"></a>第二步 token化</h3><p>通过词法分析器，将字符串解析成Token，Token中会标注出当前的Token是 <code>开始标签</code> ，还是 <code>结束标签</code> ，或者 <code>文本标签</code> 等。<br>  <img src="https://user-images.githubusercontent.com/18004081/55075904-0c84e880-50cf-11e9-85bd-c7fca3e615d4.jpg" alt="将字符转换成Token"></p><h3 id="第三步-生成Nodes并构建DOM树"><a href="#第三步-生成Nodes并构建DOM树" class="headerlink" title="第三步 生成Nodes并构建DOM树"></a>第三步 生成Nodes并构建DOM树</h3><p>浏览器会根据Tokens里记录的 <code>开始标签</code> ， <code>结束标签</code> ，将Tokens之间相互串联起来<em>（带有结束标签的Token不会生成Node）</em>。<br>Node包含了这个节点的所有属性。例如 <code>&lt;img src=&quot;xxx.png&quot; &gt;</code> 标签最终生成出的节点对象中会保存图片地址等信息。<br>  事实上，在构建DOM树时，不是要等所有的Tokens都转换成Nodes后才开始，而是一边生成Token一边采取 <code>深度遍历算法</code> 消耗Token来生成Node，如下图所示：<br>  图中有颜色的小数字代表构建的具体步骤，可以看出，首先生成出 <code>html Token</code> ,并消耗Token创建出 <code>html 节点对象</code> ，接着生成 <code>head Token</code> 并消耗Token创建出 <code>head节点对象</code> ……，当所有的Tokens都消耗完了，紧接着DOM树也就构建完了。</p><p>  <img src="https://user-images.githubusercontent.com/18004081/55075892-0989f800-50cf-11e9-8930-7525e06fd7aa.jpg" alt="构建DOM树"></p>  <p class="question">这里抛出个小问题，为什么有时在js中访问DOM时浏览器会报错呢？<p>  因为在上述的解析的过程中，如果碰到了 `script` 或者 `link` 标签，就会根据 `src` 对应的地址去加载资源，在 `script` 标签没有设置 `async/defer` 属性时，这个加载过程是 `下载并执行完全部的代码` ，此时，DOM树还没有完全创建完毕，这个时候如果js企图访问script标签后面的DOM元素，浏览器就会抛出**找不到该DOM元素**的错误。<p>  值得注意的是：从bytes到Tokens的这个过程，浏览器都可以交给其他单独的线程去处理，不会堵塞浏览器的渲染线程。但是后面的部分就都在渲染线程下进行了，也就是我们常说的js单线程环境。</p><h2 id="2-CSSOMTree的构建"><a href="#2-CSSOMTree的构建" class="headerlink" title="2.CSSOMTree的构建"></a>2.CSSOMTree的构建</h2><p>DOM会记录页面的内容，但是浏览器还需要知道这些内容该用什么样式去展示，所以还需要构建CSSOMTree。CSSOM的生成过程和DOM的生成过程十分相似，也是：1.解析，2.Token化，3.生成Nodes并构建CSSOMTree：</p><p>假设浏览器收到了下面这样一段css:<br> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">font-size</span>: <span class="number">16px</span>;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-weight</span>: bold;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span> &#123;<span class="attribute">display</span>:none;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;<span class="attribute">color</span>: red;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;<span class="attribute">float</span>: right;&#125;</span></pre></td></tr></table></figure></p><p>最终会生成如下的CSSOMTree:</p><p><img src="https://user-images.githubusercontent.com/18004081/55075893-0a228e80-50cf-11e9-8943-3c86a5875913.png" alt="构建CSSOM"></p><p>从图中可以看出，最开始 <code>body</code> 有一个样式规则是 <code>font-size:16px</code> ，之后，在body这个样式基础上每个子节点还会添加自己单独的样式规则，比如 <code>span</code> 又添加了一个样式规则 <code>color:red</code> 。正是因为样式这种类似于继承的特性，浏览器设定了一条规则：<strong>CSSOMTree需要等到完全构建后才可以被使用，因为后面的属性可能会覆盖掉前面的设置</strong>。比如在上面的css代码基础上再添加一行代码 <code>p {font-size:12px}</code> ，那么之前设置的 <code>16px</code> 将会被覆盖成 <code>12px</code>。</p><p>下面是官方给的一种解释：</p><blockquote><p>未构建完的CSSOMTree是不准确的，浏览器必须等到CSSOMTree构建完毕后才能进入下一阶段。</p><p>所以，CSS的加载速度与构建CSSOMTree的速度将直接影响首屏渲染速度，因此在默认情况下CSS被视为阻塞渲染的资源，需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。</p></blockquote><p>那么回到上面生成DOM时提到的JS问题：<strong>在标签没有设置 <code>async/defer</code> 属性时，js会阻塞DOM的生成</strong>。原因是js会改变DOMTree的内容，如果不阻塞，会出现一边生成DOM内容，一边修改DOM内容的情况，无法确保最终生成的DOMTree是确定唯一的。</p><p>同理，JS也会可以修改CSS样式，影响CSSOMTree最终的结果。而我们前面提到，不完整的CSSOMTree是不可以被使用的，如果JS试图在<strong>浏览器还未完成CSSOMTree的下载和构建</strong>时去操作CSS样式，浏览器会<strong>暂停脚本的运行和DOM的构建</strong>，直至浏览器完成了CSSOM的下载和构建。也就是说，<strong>JS脚本的出现会让CSSOM的构建阻塞DOM的构建</strong>。</p><p class="question">这里抛出个小问题，平时谈及页面性能优化，经常会强调css文件应该放在html文档中的前面引入，js文件应该放在后面引入，这么做的原因是什么呢？<p><p>举个例子：本来，DOM构建和CSSOM构建是两个过程，井水不犯河水。假设DOM构建完成需要1s，CSSOM构建也需要1s，在DOM构建了0.2s时发现了一个 <code>link</code> 标签，此时完成这个操作需要的时间大概是1.2s，如下图所示：</p><img width="900" alt="没有JS时的构建时间" src="https://user-images.githubusercontent.com/18004081/55076133-a0ef4b00-50cf-11e9-8c02-5c2ccdb13807.png"><p>而此时我们在HTML文档的中间插中入了一段JS代码，在DOM构建中间的过程中发现了这个 <code>script</code> 标签，假设这段JS代码只需要执行0.0001s，那么完成这个操作需要的时间就会变成：<br><img src="https://user-images.githubusercontent.com/18004081/55075894-0a228e80-50cf-11e9-8eb2-9ad996febcf0.jpg" alt="JS在前面时的构建时间"><br>那如果我们把css放到前面，js放到最后引入时，构建时间会变成：<br><img src="https://user-images.githubusercontent.com/18004081/55075881-068f0780-50cf-11e9-8ad9-341a57985438.jpg" alt="JS在后面时的构建时间"><br>由此可见，虽然只是插入了小小的一段只运行0.0001s的js代码，不同的引入时机也会严重影响DOMTree的构建速度。</p><p>简而言之，如果在DOM，CSSOM和JavaScript执行之间引入大量的依赖关系，可能会导致浏览器在处理渲染资源时出现大幅度延迟：</p><ul><li>当浏览器遇到一个script标签时，DOMTree的构建将被暂停，直至脚本执行完毕</li><li>JavaScript可以查询和修改DOMTree与CSSOMTree</li><li>直至CSSOM构建完毕，JavaScript才会执行</li><li>脚本在文档中的位置很重要</li></ul><h2 id="3-渲染树的构建"><a href="#3-渲染树的构建" class="headerlink" title="3.渲染树的构建"></a>3.渲染树的构建</h2><p>现在，我们已经拥有了完整的DOM树和CSSOM树。DOM 树上每一个节点对应着网页里每一个元素，CSSOM树上每个节点对应着网页里每个元素的样式，并且此时浏览器也可以通过 JavaScript 操作DOM/CSSOM树，动态改变它的结构。但是DOM/CSSOM树本身并不能直接用于排版和渲染，浏览器还会生成另外一棵树：Render树</p><p><img src="https://user-images.githubusercontent.com/18004081/55075903-0c84e880-50cf-11e9-80ec-f7a8dc86b7b7.png" alt="构建RenderTree"></p><p>接下来我们来谈几条概念</p><ul><li>Render 树上的每一个节点被称为： <code>RenderObject</code>。</li><li>RenderObject跟 DOM 节点几乎是一一对应的，当一个 <code>可见的 DOM 节点</code> 被添加到 DOM 树上时，内核就会为它生成对应的 RenderOject 添加到 Render 树上。</li><li>其中，可见的DOM节点不包括：<ul><li>一些不会体现在渲染输出中的节点（ <code>&lt;html&gt;&lt;script&gt;&lt;link&gt;….</code> ），会直接被忽略掉。</li><li>通过CSS隐藏的节点。例如上图中的 <code>span</code>节点，因为有一个CSS显式规则在该节点上设置了 <code>display:none</code> 属性，那么它在生成RenderObject时会被直接忽略掉。</li></ul></li><li>Render 树是衔接浏览器排版引擎和渲染引擎之间的<strong>桥梁</strong>，它是<strong>排版引擎的输出，渲染引擎的输入</strong>。</li></ul><p>此时的Render树上，已经包含了网页上所有可见元素的内容和位置信息  排版引擎会根据Render树的内容和结构，准确的计算出元素该在网页上的什么位置。到此，我们已经具备进入布局的一切准备条件，但是通过上面我们知道，布局后面还有一个渲染过程，那么<em>Render 树是衔接浏览器排版引擎和渲染引擎之间的桥梁，它是排版引擎的输出，渲染引擎的输入。</em>这句话是什么意思呢？</p><h4 id="RenderObject-and-RenderLayer"><a href="#RenderObject-and-RenderLayer" class="headerlink" title="RenderObject and RenderLayer"></a>RenderObject and RenderLayer</h4><blockquote><p>浏览器渲染引擎并不是直接使用Render树进行绘制，为了方便处理<strong>Positioning,Clipping,Overflow-scroll,CSS Transfrom/Opacrity/Animation/Filter,Mask or Reflection,Z-indexing</strong>等属性，浏览器需要生成另外一棵树：<strong>Layer树</strong></p></blockquote><p><img src="https://user-images.githubusercontent.com/18004081/50632777-f8c05f00-0f83-11e9-9f76-7c91bbb480fa.png" alt="1"></p><p>浏览器会为一些<strong>特定</strong>的 <code>RenderObject</code> 生成对应的 <code>RenderLayer</code> ，其中的规则是：</p><ul><li>是否是页面的根节点    <em>It’s the root object for the page</em></li><li>是否有css的一些布局属性（relative absolute or a transform)     <em>It has explicit CSS position properties (relative, absolute or a transform)</em></li><li>是否透明 <em>It is transparent</em></li><li>是否有溢出     <em>Has overflow, an alpha mask or reflection</em></li><li>是否有css滤镜     <em>Has a CSS filter</em></li><li>是否包含一个canvas元素使得节点拥有视图上下文     <em>Corresponds to canvas element that has a 3D (WebGL) context or an accelerated 2D context</em></li><li>是否包含一个video元素      <em>Corresponds to a video element</em></li></ul><p>当满足上面其中一个条件时，这个 <code>RrenderObject</code> 就会被浏览器选中生成对应的 <code>RenderLayer</code> 。至于那些没有被命运选中的RrenderObject，会从属与父节点的RenderLayer。最终，每个RrenderObject都会直接或者间接的属于一个RenderLayer。</p><p>浏览器渲染引擎在布局和渲染时会遍历整个Layer树，访问每一个 <code>RenderLayer</code> ，再遍历从属于这个RenderLayer的  <code>RrenderObject</code> ，将每一个 RenderObject 绘制出来。可以理解为：Layer 树决定了网页绘制的层次顺序，而从属于RenderLayer 的 RrenderObject决定了这个 Layer 的内容，所有的  <code>RenderLayer</code> 和  <code>RrenderObject</code> 一起就决定了网页在屏幕上最终呈现出来的内容。</p><h2 id="4-布局"><a href="#4-布局" class="headerlink" title="4.布局"></a>4.布局</h2><p>到目前为止，浏览器计算出了哪些节点是可见的以及它的信息和样式，接下来就需要计算这些节点在设备视口内的确切位置和大小，这个过程我们称之为“布局”。<br>布局最后的输出是一个“盒模型”：将所有相对测量值都转换成屏幕上的绝对像素。</p><p><img src="https://user-images.githubusercontent.com/18004081/55075883-07279e00-50cf-11e9-9aa9-33f49051855a.png" alt="布局"></p><h2 id="5-渲染"><a href="#5-渲染" class="headerlink" title="5.渲染"></a>5.渲染</h2><p>最后，既然我们知道了哪些节点可见、它们的计算样式以及几何信息，我们终于可以将这些信息传递给最后一个阶段：将渲染树中的每个节点转换成屏幕上的实际像素：浏览器通过发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。</p><p><img src="https://user-images.githubusercontent.com/18004081/55075884-07279e00-50cf-11e9-9a78-9bf5822819fb.png" alt="渲染"></p><p>至此，我们就能够在浏览器上看到漂亮的网页了</p><p class="question">这里提一个小问题：谈及页面性能优化，我们也常说要尽量减少浏览器的重排和重绘，浏览器重排和重绘时究竟做了哪些工作呢？<p>我们平时常说的重排，其实就是浏览器计算render树，布局到渲染的这个过程，而重绘就是计算layer树到渲染的这个过程，每当触发一次重绘和重排时，浏览器都需要重新经过一遍上述的计算。很显然，重排会产生比重绘更大的开销，但无论是重排还是重绘，都会给浏览器渲染线程造成很大的负担，所以，我们在实际生产中要严格注意减少重排和重绘的触发。至于如何减少重排和重绘的次数，这里就不多做展开了，详细请听下回分解~<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>经过：1.构建对象模型（DOM，CSSOM），2.构建渲染树（RenderTree），3.布局，4.渲染 这几个步骤后，我们就能在浏览器上看到漂亮的网页啦。</li><li>CSS被视为阻塞渲染的资源，应放到代码的头部尽快加载。</li><li>同步的JavaScript会暂停DOMTree的构建，应放到代码的尾部最后加载，或者使用 <code>async/defer属性</code>异步加载JavaScript。</li><li>重排和重绘会给浏览器渲染线程造成很大的负担，尽量减少重排和重绘的触发次数</li></ul><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=zh-cn</a></p><p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn</a></p><p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css?hl=zh-cn</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&amp;mid=2650588806&amp;idx=1&amp;sn=408a54e7c8102fd6944c9a40b119015a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&amp;mid=2650588806&amp;idx=1&amp;sn=408a54e7c8102fd6944c9a40b119015a&amp;scene=21#wechat_redirect</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于元素到窗口距离的一些整理</title>
      <link href="/2018/10/30/2018/%E5%85%B3%E4%BA%8E%E5%85%83%E7%B4%A0%E5%88%B0%E7%AA%97%E5%8F%A3%E8%B7%9D%E7%A6%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%95%B4%E7%90%86/"/>
      <url>/2018/10/30/2018/%E5%85%B3%E4%BA%8E%E5%85%83%E7%B4%A0%E5%88%B0%E7%AA%97%E5%8F%A3%E8%B7%9D%E7%A6%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在做懒加载和一些高度改变的动画时，我们需要知道元素在窗口中的位置，下面是这次整理的一些元素偏移量介绍</p><p><img src="https://user-images.githubusercontent.com/18004081/47722599-bcc00380-dc8d-11e8-8c6a-642b83208a48.png" alt="1"></p><h2 id="1-浏览器的一些属性"><a href="#1-浏览器的一些属性" class="headerlink" title="1. 浏览器的一些属性"></a>1. 浏览器的一些属性</h2><p>screen.height/width，屏幕的高/宽，与显示器的分辨率有关</p><p>screen.availHeight/availWidth，屏幕有效区域的高/宽，相比较height/width少去了菜单栏的所占位</p><p>scrollY/pageYOffset，浏览器垂直滚动条滚动的距离，随着滚动条位置的不同而改变</p><p>dom.scrollTo(x,y)，修改浏览器的滚动位置</p><p><strong>screen值获取到的是整个屏幕的宽高,并不会随着浏览器窗口缩放而改变</strong></p><h2 id="2-offsetParent（定位父级）"><a href="#2-offsetParent（定位父级）" class="headerlink" title="2. offsetParent（定位父级）"></a>2. offsetParent（定位父级）</h2><p>在理解偏移大小之前，首先要理解offsetParent。人们并没有把offsetParent翻译为偏移父级，而是翻译成定位父级，很大原因是offsetParent与定位有关。定位父级offsetParent的定义是：<strong>与当前元素最近的经过定位(position不等于static)的父级元素。</strong>主要分为下列几种情况：</p><ul><li>元素自身有fixed定位，offsetParent的结果为null。当元素自身有fixed固定定位时，我们知道固定定位的元素相对于视口进行定位，此时没有定位父级，offsetParent的结果为null</li><li>元素自身无fixed定位，且父级元素都未经过定位，offsetParent的结果为 <code>&lt;body&gt;</code> 。</li><li>元素自身无fixed定位，且父级元素存在经过定位的元素，offsetParent的结果为离自身元素最近的经过定位的父级元素</li><li><code>&lt;body&gt;</code> 元素的parentNode是null</li></ul><h2 id="3-offsetLeft（offsetTop"><a href="#3-offsetLeft（offsetTop" class="headerlink" title="3. offsetLeft（offsetTop)"></a>3. offsetLeft（offsetTop)</h2><p>只读</p><p>返回当前元素左上角相对于  HTMLElement.offsetParent 节点的左边界(上边界）偏移的像素值</p><h2 id="4-offsetWidth（offsetHeight"><a href="#4-offsetWidth（offsetHeight" class="headerlink" title="4. offsetWidth（offsetHeight)"></a>4. offsetWidth（offsetHeight)</h2><p>只读</p><p>返回该元素的像素高度，高度包含该元素的垂直内边距和边框，其方向上的滚动条，不包含:before或:after等伪类元素的高度。<br>对块级元素来说，offsetTop、offsetLeft、offsetWidth 及 offsetHeight 描述了元素相对于 offsetParent 的边界框。</p><p><strong>然而，对于可被截断到下一行的行内元素<em>（如 span）</em>，offsetTop 和 offsetLeft 描述的是第一个边界框的位置（使用 Element.getClientRects() 来获取其宽度和高度），而 offsetWidth 和 offsetHeight 描述的是边界框的尺寸（使用 Element.getBoundingClientRect 来获取其位置）。因此，使用 offsetLeft、offsetTop、offsetWidth、offsetHeight 来对应 left、top、width 和 height 的一个盒子将不会是文本容器 span 的盒子边界。</strong></p><h2 id="5-scrollTop（scrollLeft"><a href="#5-scrollTop（scrollLeft" class="headerlink" title="5. scrollTop（scrollLeft)"></a>5. scrollTop（scrollLeft)</h2><p>获取和设置</p><p>元素的顶部到它的最顶部可见内容（的顶部）的距离的度量。当一个元素的内容<strong>没有产生垂直方向的滚动条</strong>，那么它的 <strong>scrollTop 值为0</strong>。</p><p>scrollTop 可以被设置为任何整数值，同时注意：</p><ul><li>如果一个元素不能被滚动（例如，它没有溢出，或者这个元素有一个”non-scrollable”属性）， scrollTop将被设置为0</li><li>设置scrollTop的值小于0，scrollTop 被设为0</li><li>如果设置了超出这个容器可滚动的值, scrollTop 会被设为最大值.</li></ul><h2 id="6-scrollHeight（scrollWidth"><a href="#6-scrollHeight（scrollWidth" class="headerlink" title="6. scrollHeight（scrollWidth)"></a>6. scrollHeight（scrollWidth)</h2><p>只读</p><p>一个元素内容高度的度量，包括由于溢出导致的视图中不可见内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断一个元素是否滚动到底部</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果元素滚动到底，下面等式返回true，没有则返回false.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">element.scrollHeight - element.scrollTop === element.clientHeight</span></pre></td></tr></table></figure><h2 id="7-getBoundingClientReact"><a href="#7-getBoundingClientReact" class="headerlink" title="7. getBoundingClientReact"></a>7. getBoundingClientReact</h2><p>返回值是一个 DOMRect 对象，这个对象是由该元素的 getClientRects() 方法返回的一组矩形的集合</p><p>元素对于视口区域的距离，当元素发生滚动时，代表位置的属性会随着变化</p><p>具体每个属性代表什么距离参照大图</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上传文件</title>
      <link href="/2018/09/27/2018/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
      <url>/2018/09/27/2018/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>每次用原生写文件上传都要重新查一遍资料，这次写完总结一下吧</p><h3 id="html-css"><a href="#html-css" class="headerlink" title="html css"></a>html css</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">//将input调成透明（opacity: 0），移到一个不重要的位置上去</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">'upload'</span>&gt;</span>上传<span class="tag">&lt; /<span class="attr">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"upload"</span>/&gt;</span></span></pre></td></tr></table></figure><h3 id="js-ajax"><a href="#js-ajax" class="headerlink" title="js ajax"></a>js ajax</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//触发input的onchange事件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//ajax</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> FormData()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">data.append(<span class="string">'file'</span>,$(<span class="string">'#upload'</span>)[<span class="number">0</span>].files[<span class="number">0</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    url:<span class="string">'upload'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    type:<span class="string">'POST'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    data:data,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    dataType:<span class="string">'JSON'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    cache:<span class="literal">false</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    processData:<span class="literal">false</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    contentType:<span class="literal">false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;).done(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'上传成功'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;).file(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'上传失败'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用postCSS进行css处理</title>
      <link href="/2018/09/05/2018/postcss/"/>
      <url>/2018/09/05/2018/postcss/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Visual Studio Code对Node.js进行断点调试</title>
      <link href="/2018/07/20/2018/VS%E5%AF%B9Node%E8%BF%9B%E8%A1%8C%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/"/>
      <url>/2018/07/20/2018/VS%E5%AF%B9Node%E8%BF%9B%E8%A1%8C%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-进入vscode，前往虫子的那个页面"><a href="#1-进入vscode，前往虫子的那个页面" class="headerlink" title="1.进入vscode，前往虫子的那个页面"></a>1.进入vscode，前往虫子的那个页面</h2><p><img src="https://user-images.githubusercontent.com/18004081/47766305-feda5b00-dd08-11e8-919e-ac5645383506.png" alt="image"></p><h2 id="2-点击调试旁边的那个下拉框，选择“添加配置”"><a href="#2-点击调试旁边的那个下拉框，选择“添加配置”" class="headerlink" title="2.点击调试旁边的那个下拉框，选择“添加配置”"></a>2.点击调试旁边的那个下拉框，选择“添加配置”</h2><p><img src="https://user-images.githubusercontent.com/18004081/47766309-039f0f00-dd09-11e8-8ca2-8cd0fe1f7f46.png" alt="image"></p><h2 id="3-选择Node-js-启动程序"><a href="#3-选择Node-js-启动程序" class="headerlink" title="3.选择Node.js:启动程序"></a>3.选择Node.js:启动程序</h2><p><img src="https://user-images.githubusercontent.com/18004081/47766317-0ef23a80-dd09-11e8-9be0-fb79fa49e115.png" alt="image"></p><p>之后，项目的根目录会生成一个.vscode的目录，这个目录中存放了各种各样的VScode编译器的配置。现在这个文件夹下面就放了一个叫launch.json的文件，是我们debug的配置入口。<br><img src="https://user-images.githubusercontent.com/18004081/47766325-174a7580-dd09-11e8-9ada-1fde28918a00.png" alt="image"></p><ul><li>现在 launch.json已经自动为我们生成了一些配置项字段，具体的配置项字段可以参考<a href="https://go.microsoft.com/fwlink/?linkid=830387" target="_blank" rel="noopener">https://go.microsoft.com/fwlink/?linkid=830387</a> 的解释。</li><li>其中比较重要的是<strong>program</strong>字段，这个字段定义了整个调试器的入口，开启调试器的时候会从这个入口启动程序。</li><li>一般生成 lanch.json的时候这个字段已经有值了，这是因为VScode在初始化launch.json的时候会查看项目的<strong>package.json</strong>中是否有包含键名为<strong>start</strong>的scripts，如果有的话，就会把start配置的内容作为program字段的值。</li><li>我这个项目是通过 dev 命令来启动服务的，将dev后面的内容修改到 program 下：</li></ul><p><img src="https://user-images.githubusercontent.com/18004081/47766332-203b4700-dd09-11e8-8ac0-84b744f6b610.png" alt="image"></p><ul><li>如果启动调试器的时候需要添加参数，可以通过<strong>args</strong>字段来设置，环境通过 env 字段来设置，例子如下：</li></ul><p><img src="https://user-images.githubusercontent.com/18004081/47766346-27faeb80-dd09-11e8-99ad-6bffb3b20925.png" alt="image"></p><h2 id="4-点击调试旁边绿色运行箭头，就可以开始调试了，可以通过控制面板来查看调试的信息"><a href="#4-点击调试旁边绿色运行箭头，就可以开始调试了，可以通过控制面板来查看调试的信息" class="headerlink" title="4.点击调试旁边绿色运行箭头，就可以开始调试了，可以通过控制面板来查看调试的信息"></a>4.点击调试旁边绿色运行箭头，就可以开始调试了，可以通过控制面板来查看调试的信息</h2><p><img src="https://user-images.githubusercontent.com/18004081/47766355-2df0cc80-dd09-11e8-9b94-70b1f0b65b7c.png" alt="image"></p><h2 id="5-然后我们设置一个断点，重新启动调试服务"><a href="#5-然后我们设置一个断点，重新启动调试服务" class="headerlink" title="5.然后我们设置一个断点，重新启动调试服务"></a>5.然后我们设置一个断点，重新启动调试服务</h2><p><img src="https://user-images.githubusercontent.com/18004081/47766365-35b07100-dd09-11e8-8236-02528f333d8c.png" alt="image"></p><p> 运行的调试面板大概就如上图所示，调试控制台面板亮着的按钮从左到右依次是运行，单步跳过，单步调试，单步跳出，重启和停止调试。当鼠标放在断点前的变量或者参数上，可以查看该变量当前的数值，与Chrome开发者工具的调试一致。可以在面板左边那里查看上下文环境，在监视里面监听关注的变量当前值，控制台会显示console.log的打印值。还是很很很很方便的~</p>]]></content>
      
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css3 Grid Layout 简单介绍与基本属性</title>
      <link href="/2018/07/11/2018/grid/"/>
      <url>/2018/07/11/2018/grid/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Service Workers</title>
      <link href="/2017/12/27/2017/serviceworkers/"/>
      <url>/2017/12/27/2017/serviceworkers/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>service是一个注册在一个指定源和路径下，由事件驱动<a href="https://github.com/includeios/document/issues/2" target="_blank" rel="noopener">web worker</a> ，通过注册的js文件控制相关联的页面，拦截或修改访问和资源请求。赋予你很大很大的权限去控制你的app在某一个状态下的表现（最常使用在离线的情况下）</p><p>由于servive worker是web workers类型中的一种，同样也运行在一个worker上下文环境中，因此web worker有的特性他都会有：比如不能访问dom，运行在一个单独线程下而不会阻塞主线程，完全异步的设计致使同步的xhr和localStorage都不能被使用（但是可以使用IndexedDB）</p><p>出于安全考虑，service workers只能在https下运行，因为其逆天的可以伪造，过滤，修改网络请求的功能如果有人在中间恶意攻击情况会非常糟糕，在火狐浏览器中，service worker会不能使用如果用户打开了用户隐私模式。而service workers之所以优于以前的同类尝试（如AppCache），是因为它们无法支持当操作出错时终止操作。Service workers可以更细致地控制每一件事情。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>service workers拥有一个完全独立与web页面的生命周期</p><ul><li><p>Registration 注册 （准备）<br>service worker首次进入页面时会调用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerContainer/register" target="_blank" rel="noopener">ServiceWorkerContainer.register()</a>方法注册。如果注册成功，service worker就会被下载到客户端并尝试之后的安装和激活，作用于整个域内用户可访问的URL，或者其特定子集。</p></li><li><p>Download 下载<br>在用户第一次尝试打开由service worker控制的页面时，service worker就会立刻被下载。之后，service worker会每一段时间就会下载一次，隔的时间最长不会超过24小时—-为了确保js代码都是相对比较有效的</p></li><li><p>Install 安装<br>安装会在service worker第一次下载，或者新下载的文件与旧版本不一样时开始。安装时可以通过监听<a href="https://developer.mozilla.org/en-US/docs/Web/API/InstallEvent" target="_blank" rel="noopener">InstallEvent</a>事件来做一些准备工作，比如使用storageAPI来做一些缓存，放置一些资源为离线时做准备。如果安装成功，进入激活状态，安装失败（文件加载或缓存失败）会在下次继续尝试安装~</p></li><li><p>Activate 激活<br>如果已经有启动了的service worker，新版本会处于一种叫worker in waiting的状态<em>(在后台安装却不会立即被激活)</em>，直到所有的页面都不再使用旧版本的serviceworker，新版本才会被激活。我们可以使用ServiceWorkerGlobalScope.skipWaiting()跳过这个过程。active状态可以监听activate even，在这个事件里很适合去清除/替换那些在上一个版本的service worker时做的缓存。<br><img src="https://user-images.githubusercontent.com/18004081/47765479-1f081b00-dd05-11e8-84ee-065b9e5a3424.png" alt="image"></p></li></ul><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><ul><li><strong>installEvent</strong>一般用来做一些准备工作，比如使用storage API来做一些缓存，放置一些资源为离线时做准备</li><li><strong>activateEven</strong>很适合去清除/替换那些在上一个版本的service worker时做的缓存                  </li><li><strong>FetchEvent</strong>可以对你发起的http请求做处理，你可以把response任意蹂躏成你想要的样子，通过FetchEvent.respondWith 方法返回</li><li>由于oninstall和onactivate 需要一段时间后才能完成，service worker提供了一个叫<strong>waitUntil</strong>的方法，一旦oninstall或者onactivate完成就立刻被回调，接收一个promise,在这个promise没有成功的resolved前功能性的事件不会被分配到service worker下</li></ul><h2 id="总体来说Serive-Workers适合做"><a href="#总体来说Serive-Workers适合做" class="headerlink" title="总体来说Serive Workers适合做"></a>总体来说Serive Workers适合做</h2><ol><li><p>后台资源同步</p></li><li><p>响应其他源的资源请求</p></li><li><p>集中进行一些计算成本高的数据更新，同时多个页面可以使用同一套数据</p></li><li><p>后台服务钩子</p></li><li><p>自定义模板用于特定URL模式</p></li><li><p>性能增强，比如预取用户可能需要的资源，比如相册中的后面数张图片</p></li></ol><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><img src="https://user-images.githubusercontent.com/18004081/47765488-2a5b4680-dd05-11e8-9ea4-ee8fcb792c03.png" alt="image"><br><img src="https://user-images.githubusercontent.com/18004081/47765512-4363f780-dd05-11e8-82ce-b607045a9275.png" alt="image"></p><h2 id="源文章地址："><a href="#源文章地址：" class="headerlink" title="源文章地址："></a>源文章地址：</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web Workers</title>
      <link href="/2017/12/22/2017/webworkers/"/>
      <url>/2017/12/22/2017/webworkers/</url>
      
        <content type="html"><![CDATA[<p>12月20号发布的Safri浏览器内核webkit表示自己开始支持service workers，这就意味的主流浏览器（window下的chorme和Firefox，ios下的Safri，ie…..嗯，先不管他）都支持service workers，web app离线缓存页面将不是梦~</p><p>Service workers 其实是web workers中的一种类型，所以在学习使用service workers之前，我们先来看看web workers是啥，有哪些类型，都能干些什么吧</p><h2 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h2><p><strong>Web Workers</strong>使script能够单独地运行在一个独立的线程中，这意味着我们可以将一些有复杂的逻辑计算的js放在其他线程下工作，而不去阻塞主线程（一般是ui渲染）的运行</p><h2 id="概念和使用"><a href="#概念和使用" class="headerlink" title="概念和使用"></a>概念和使用</h2><p>worker是通过构造函数【Worker(filterName.js) 】生出来的Object，这个js文件里写的代码会单独运行在一个新的执行环境（context）中而不是当前的window，这个工作环境其实是一个<a href="https://link.jianshu.com/?t=https://developer.mozilla.org/en-US/docs/Web/API/DedicatedWorkerGlobalScope" target="_blank" rel="noopener">DedicatedWorkerGlobalScope</a>对象，<em>（对于dedicated类型的worker是他，对于shared类型的worker是<a href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorkerGlobalScope" target="_blank" rel="noopener">SharedWorkerGlobalScope</a>)</em>.</p><p>理论上在这个worker线程下你想干啥就干啥，但是还是有一些例外，比如，你没有办法在worker中直接操作dom，也没办法使用window对象一些默认的方法和属性，不过呢，window下还是有很多功能你可以直接使用的，像webSockets，一些存储工具indexedDB啊，还有一个火狐浏览器搞的Data Store啊~，具体请参考 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers" target="_blank" rel="noopener">Functions and classes available to workers</a></p><p>workers与主线程间通过messages渠道来传递数据，发送message的方法都是<strong>postMessage</strong>,接受数据都是通过监听<strong>onmessage</strong>事件，值得注意的是数据在传输时是通过<strong>复制</strong>的方法而不是共享~</p><p>有的时候，workers可能会生成新的workers….，只要这些构建这些workers的js文件在同一源下就可以了。worker 可以通过XMLHttpRequest来访问网络，只是[XMLHttpRequest<a href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker" target="_blank" rel="noopener">4</a>的responseXML和channel这两个属性将总是null。</p><h2 id="workers类型"><a href="#workers类型" class="headerlink" title="workers类型"></a>workers类型</h2><p>除了dedicated(专用）类型的workers,还有下面几种类型</p><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker" target="_blank" rel="noopener">SharedWorker</a><br>共享类型的workers可以被好几个scripts运行在同一个源中不同的windows下，IFrames下，等等….，相比较dedicated workers，shared workers更复杂一点是因为在进行传输时需要启动<strong>port</strong>，具体请参考SharedWorkers</p></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">ServiceWorkers</a><br>ServiceWorkers一般作为web应用程序、浏览器和网络（如果可用）之前的代理服务器。主要的作用是：</p><pre><code>1.后台消息传递2.网络代理，转发请求，伪造响应3.离线缓存，并且会在网络是否合适的情况下采取合适的行动更新驻留在服务器上的资源4.消息推送</code></pre></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Gecko/Chrome/API/ChromeWorker" target="_blank" rel="noopener">Chrome Workers</a><br>ChromeWorker 是火狐浏览器自己弄出来的东西，如果您正在开发附加组件，并且希望在扩展程序中使用worker，同时在你的worker中有访问<a href="https://developer.mozilla.org/en-US/docs/Mozilla/js-ctypes" target="_blank" rel="noopener">js-ctypes</a>的权限，那么你可以使用它。</p></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API#Audio_Workers" target="_blank" rel="noopener">Audio Workers</a><br>Audio Workers可以直接在webworker的上下文中完成脚本化音频处理。</p></li></ul><h2 id="简单示例链接"><a href="#简单示例链接" class="headerlink" title="简单示例链接"></a>简单示例链接</h2><p>dedicatedWorkesr: <a href="https://github.com/mdn/simple-web-worker" target="_blank" rel="noopener">github地址</a>，<a href="http://mdn.github.io/simple-web-worker/" target="_blank" rel="noopener">在线实例</a><br>SharedWorkers:<a href="https://github.com/mdn/simple-shared-worker" target="_blank" rel="noopener">github地址</a>github地址，<a href="http://mdn.github.io/simple-shared-worker/" target="_blank" rel="noopener">在线实例</a>在线实例<br>ServiceWorkers:<a href="https://github.com/mdn/sw-test/" target="_blank" rel="noopener">github地址</a>，<a href="https://mdn.github.io/sw-test/" target="_blank" rel="noopener">在线实例</a></p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><img src="https://upload-images.jianshu.io/upload_images/9673192-9c514f4c5cbe8181.png" alt=""><br><img src="https://user-images.githubusercontent.com/18004081/47764460-40b2d380-dd00-11e8-9e0b-3900adcbfb33.png" alt="image"></p><h2 id="源文章地址和参考资料："><a href="#源文章地址和参考资料：" class="headerlink" title="源文章地址和参考资料："></a>源文章地址和参考资料：</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API</a></p><p><a href="http://web.jobbole.com/84792/" target="_blank" rel="noopener">http://web.jobbole.com/84792/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
